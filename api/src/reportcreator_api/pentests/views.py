import contextlib
import functools
from io import BytesIO
from django.http import FileResponse, Http404, StreamingHttpResponse
from django.shortcuts import get_object_or_404
from django.db import transaction
from django.core.files.base import ContentFile
from rest_framework import viewsets, mixins, status, filters, exceptions
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.pagination import CursorPagination
from rest_framework.serializers import Serializer
from rest_framework.settings import api_settings
from django_filters.rest_framework import DjangoFilterBackend
from reportcreator_api.archive.import_export import export_project_types, export_projects, export_templates, import_project_types, import_projects, import_templates

from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_PREDEFINED
from reportcreator_api.pentests.customfields.types import field_definition_to_dict
from reportcreator_api.pentests.models import FindingTemplate, LockStatus, PentestFinding, PentestProject, ProjectType, ReportSection, SourceEnum, \
    UploadedAsset, UploadedImage
from reportcreator_api.pentests.permissions import IsAuthenticatedOrRetrieve, IsDesignerOrReadOnly, IsTemplateEditorOrReadOnly, ProjectReadOnlyPermissions, \
     ProjectSubresourceReadonlyPermissions, SendBeaconAuthentication
from reportcreator_api.pentests.render import PdfRenderingError, post_process_pdf, render_pdf, render_pdf_preview
from reportcreator_api.pentests.serializers import FindingTemplateSerializer, ImportSerializer, PentestFindingFromTemplateSerializer, PentestFindingSerializer, \
    PentestProjectReadonlySerializer, PentestProjectSerializer, PreviewPdfOptionsSerializer, ProjectTypeDetailSerializer, ProjectTypePreviewSerializer, \
        ProjectTypeShortSerializer, ProjectTypeCopySerializer, PublishPdfOptionsSerializer, ReportSectionSerializer, UploadedAssetSerializer, UploadedImageSerializer
from reportcreator_api.utils.error_messages import MessageLevel, format_messages


class ViewSetMixinHelper:
    def get_serializer_for_action(self, action, **kwargs):
        action_bak = self.action
        try:
            self.action = action
            return self.get_serializer(**kwargs)
        finally:
            self.action = action_bak


class LockableViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action in ['lock', 'unlock']:
            return Serializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def lock(self, request, *args, **kwargs):
        instance = self.get_object()
        
        lock_status = instance.lock(request.user, refresh_lock=request.data.get('refresh_lock', True))
        instance.refresh_from_db()
        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data, status={
            LockStatus.CREATED: status.HTTP_201_CREATED,
            LockStatus.REFRESHED: status.HTTP_200_OK,
            LockStatus.FAILED: status.HTTP_403_FORBIDDEN
        }[lock_status])

    @action(detail=True, methods=['post'], authentication_classes=[SendBeaconAuthentication] + api_settings.DEFAULT_AUTHENTICATION_CLASSES)
    def unlock(self, request, *args, **kwargs):
        instance = self.get_object()
        if not instance.unlock(request.user):
            raise exceptions.PermissionDenied('Could not lock object')

        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data)

    @contextlib.contextmanager
    def _ensure_locked(self, instance):
        was_locked = instance.is_locked
        if instance.lock(self.request.user, refresh_lock=False) == LockStatus.FAILED:
            raise exceptions.PermissionDenied('Could not lock object')
        yield instance
        if not was_locked and instance.pk is not None:
            instance.unlock(self.request.user)

    def perform_update(self, serializer):
        with self._ensure_locked(serializer.instance):
            return super().perform_update(serializer)

    def perform_destroy(self, instance):
        with self._ensure_locked(instance):
            return super().perform_destroy(instance)


class ExportImportViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action == 'export':
            return Serializer
        elif self.action == 'import_':
            return ImportSerializer
        else:
            return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def export(self, request, **kwargs):
        instance = self.get_object()
        archive = self.perform_export([instance])
        return StreamingHttpResponse(streaming_content=archive, headers={
            'Content-Type': 'application/octet-stream',
            'Content-Disposition': f'inline',
        })
    
    def perform_export(self, instances):
        pass

    @action(detail=False, url_path='import', methods=['post'])
    def import_(self, request, **kwargs):
        import_serializer = self.get_serializer(data=request.data)
        import_serializer.is_valid(raise_exception=True)

        with import_serializer.validated_data['file'].open('rb') as f:
            imported_instances = self.perform_import(f, data=import_serializer.validated_data)
        result_serializer = self.get_serializer_for_action('get', instance=imported_instances, many=True)
        return Response(result_serializer.data, status=status.HTTP_201_CREATED)
    
    def perform_import(self, archive, data):
        pass


class CopyViewSetMixin:
    def get_serializer_class(self):
        if self.action == 'copy':
            return Serializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def copy(self, request, *args, **kwargs):
        request_serializer = self.get_serializer(data=request.data)
        request_serializer.is_valid(raise_exception=True)

        instance = self.get_object().copy(request_serializer.data)
        response_serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(response_serializer.data, status=status.HTTP_201_CREATED)


class ProjectTypeViewSet(LockableViewSetMixin, CopyViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsDesignerOrReadOnly]
    queryset = ProjectType.objects.select_related('lock_info_data', 'lock_info_data__user').all()
    serializer_class = ProjectTypeDetailSerializer
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['name']
    filterset_fields = ['language']
    
    def get_serializer_class(self):
        if self.action == 'list':
            return ProjectTypeShortSerializer
        elif self.action == 'preview':
            return ProjectTypePreviewSerializer
        elif self.action == 'copy':
            return ProjectTypeCopySerializer
        return super().get_serializer_class()
    
    def get_queryset(self):
        qs = super().get_queryset()
        if self.action == 'list':
            qs = qs.filter(source__in=[SourceEnum.CREATED, SourceEnum.IMPORTED])
        return qs
    
    @action(detail=True, methods=['post'])
    def preview(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        try:
            d = serializer.data
            pdf_preview = render_pdf_preview(
                report_template=d['report_template'],
                report_styles=d['report_styles'],
                report_preview_data=d['report_preview_data'] or {},
                project_type=instance
            )
            return FileResponse(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, url_path='predefinedfields/findings')
    def get_predefined_finding_fields(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FINDING_FIELDS_PREDEFINED))

    def perform_export(self, instances):
        return export_project_types(instances)
    
    def perform_import(self, archive, data):
        return import_project_types(archive)


class PentestProjectViewSet(CopyViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectReadOnlyPermissions]
    serializer_class = PentestProjectSerializer
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['name']
    filterset_fields = ['language', 'readonly']

    def get_serializer_class(self):
        if self.action == 'generate':
            return PublishPdfOptionsSerializer
        elif self.action == 'preview':
            return PreviewPdfOptionsSerializer
        elif self.action == 'readonly':
            return PentestProjectReadonlySerializer
        return super().get_serializer_class()

    def get_queryset(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type') \
            .prefetch_related('pentesters')
        if self.action in ['check', 'preview', 'generate']:
            qs = qs.prefetch_related('sections', 'findings')
        return qs

    @action(detail=True, methods=['post'])
    def preview(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data)
        serializer.is_valid(raise_exception=True)
        options = serializer.validated_data

        try:
            pdf_preview = render_pdf(project_type=options.get('project_type') or instance.project_type, project=instance)
            return FileResponse(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def check(self, request, *args, **kwargs):
        instance = self.get_object()
        res = instance.perform_checks()
        return Response(data=format_messages(res))
    
    @action(detail=True, methods=['post'])
    def generate(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data)
        serializer.is_valid(raise_exception=True)
        options = serializer.validated_data

        # Check for errors
        if (messages := format_messages(instance.perform_checks())) and messages.get(MessageLevel.ERROR.value):
            return Response(data=messages, status=status.HTTP_400_BAD_REQUEST)
        
        # Generate final report; optionally encrypt PDF if a password was supplied
        try:
            pdf = render_pdf(project_type=options.get('project_type') or instance.project_type, project=instance)
            pdf = post_process_pdf(pdf, password=options.get('password'))

            if options.get('readonly'):
                instance.readonly = True
                instance.save()

            return FileResponse(BytesIO(pdf), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['get', 'patch', 'put'])
    def readonly(self, request, *args, **kwargs):
        if request.method == 'get':
            return self.retrieve(request, *args, **kwargs)
        else:
            return self.partial_update(request, *args, **kwargs)
    
    def perform_export(self, instances):
        return export_projects(instances)
    
    def perform_import(self, archive, data):
        projects = import_projects(archive)
        # Add importer user as member
        self.request.user.projects.add(*projects)
        return projects


class PentestFindingViewSet(LockableViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourceReadonlyPermissions]
    serializer_class = PentestFindingSerializer
    pagination_class = None
    lookup_field = 'finding_id'

    def get_serializer_class(self):
        if self.action == 'fromtemplate':
            return PentestFindingFromTemplateSerializer
        return super().get_serializer_class()

    @functools.cache
    def get_project(self):
        return PentestProject.objects \
            .select_related('project_type') \
            .get(pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def get_queryset(self):
        return PentestFinding.objects \
            .only_permitted(self.request.user) \
            .filter(project=self.kwargs['project_pk']) \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')

    @action(detail=False, methods=['post'])
    def fromtemplate(self, request, *args, **kwargs):
        return super().create(request, *args, **kwargs)


class ReportSectionViewSet(LockableViewSetMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourceReadonlyPermissions]
    serializer_class = ReportSectionSerializer
    pagination_class = None
    lookup_field = 'section_id'

    def get_queryset(self):
        qs = ReportSection.objects \
            .only_permitted(self.request.user) \
            .filter(project__id=self.kwargs['project_pk']) \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')
        if self.request.method in ['PUT', 'PATCH']:
            # Lock project with select_for_update because all section fields of a report are stored in the same DB entity (project).
            # Locking does not prevent race conditions on updating because multiple locks can exist for the same DB object.
            # Therefore updates need to be serialized with select_for_update such that no race conditions occur.
            qs = qs.select_for_update(of=['self', 'project'])
        return qs

    @functools.cache
    def get_project(self):
        return PentestProject.objects \
            .select_related('project_type') \
            .get(pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def list(self, *args, **kwargs):
        sections = self.get_queryset()
        # Sort sections
        if sections:
            section_order = [s.get('id') for s in sections[0].project_type.report_sections]
            sections = sorted(sections, key=lambda s: section_order.index(str(s.section_id)))

        serializer = self.get_serializer(sections, many=True)
        return Response(serializer.data)

    def update(self, request, *args, **kwargs):
        with transaction.atomic():
            return super().update(request, *args, **kwargs)


class UploadedFileViewSetMixin:
    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        return FileResponse(instance.file.open())

    @action(detail=False, url_path='name/(?P<filename>[^/]+)')
    def retrieve_by_name(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())
        instance = get_object_or_404(queryset, name=kwargs['filename'])
        self.check_object_permissions(request, instance)
        return FileResponse(instance.file.open())


class UploadedImageViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourceReadonlyPermissions]
    serializer_class = UploadedImageSerializer

    def get_queryset(self):
        qs = UploadedImage.objects \
            .filter(linked_object=self.kwargs['project_pk'])
        if not self.request.user.is_anonymous:
            qs = qs.only_permitted(self.request.user)
        return qs

    @functools.cache
    def get_project(self):
        return PentestProject.objects.get(pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }


class UploadedAssetViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsDesignerOrReadOnly]
    serializer_class = UploadedAssetSerializer

    def get_queryset(self):
        return UploadedAsset.objects \
            .filter(linked_object=self.kwargs['projecttype_pk'])

    @functools.cache
    def get_project_type(self):
        return ProjectType.objects.get(pk=self.kwargs['projecttype_pk'])
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project_type': self.get_project_type(),
        }


class FindingTemplatePagination(CursorPagination):
    ordering = ['-usage_count', '-risk_score', '-created']


class FindingTemplateViewSet(LockableViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    queryset = FindingTemplate.objects.select_related('lock_info_data', 'lock_info_data__user').all()
    serializer_class = FindingTemplateSerializer
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['title', 'tags', 'language']
    filterset_fields = ['language']
    pagination_class = FindingTemplatePagination
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsTemplateEditorOrReadOnly]

    def paginate_queryset(self, queryset):
        return super().paginate_queryset(queryset)

    @action(detail=False)
    def fielddefinition(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FindingTemplate.field_definition))

    def perform_export(self, instances):
        return export_templates(instances)
    
    def perform_import(self, archive, data):
        return import_templates(archive)

