import contextlib
import functools
from io import BytesIO
import uuid
from django.http import FileResponse, Http404
from django.shortcuts import get_object_or_404
from rest_framework import viewsets, mixins, status, filters, serializers
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.pagination import CursorPagination
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_PREDEFINED
from reportcreator_api.pentests.customfields.types import field_definition_to_dict

from reportcreator_api.pentests.models import FindingTemplate, LockStatus, PentestFinding, PentestProject, ProjectType, UploadedAsset, UploadedImage
from reportcreator_api.pentests.permissions import IsAuthenticatedOrRetrieve
from reportcreator_api.pentests.render import PdfRenderingError, post_process_pdf, render_pdf, render_pdf_preview
from reportcreator_api.pentests.serializers import FindingTemplateSerializer, PentestFindingFromTemplateSerializer, PentestFindingSerializer, PentestProjectDetailSerializer, PentestProjectShortSerializer, ProjectTypeDetailSerializer, ProjectTypePreviewSerializer, ProjectTypeShortSerializer, PublishPdfOptionsSerializer, ReportSectionSerializer, UploadedAssetSerializer, UploadedImageSerializer
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.error_messages import MessageLevel, format_messages


class LockableViewSetMixin:
    @action(detail=True, methods=['post'])
    def lock(self, request, *args, **kwargs):
        instance = self.get_object()
        
        lock_status = instance.lock(request.user)
        if lock_status == LockStatus.FAILED:
            return Response({
                'error': 'Could not lock object',
            }, status=status.HTTP_403_FORBIDDEN)
        
        serializer = self.get_serializer(instance)
        return Response(serializer.data, status=status.HTTP_201_CREATED if lock_status == LockStatus.CREATED else status.HTTP_200_OK)

    @action(detail=True, methods=['post'], permission_classes=[])
    def unlock(self, request, *args, **kwargs):
        if request.user.is_anonymous:
            # Workaround such that this API endpointLockMixin.unlock works with sendbeacon
            # SendBeacon does not support supplying headers (including Authorization header)
            # Fake authentication by getting user via ID such that this view works correctly
            request.user = PentestUser.objects.get(id=request.stream.read().decode())

        instance = self.get_object()
        if not instance.unlock(request.user):
            return Response({
                'error': 'Could not unlock object'
            }, status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(instance)
        return Response(serializer.data)

    @contextlib.contextmanager
    def _ensure_locked(self, instance):
        was_locked = instance.is_locked
        if not instance.lock(self.request.user):
            return Response({
                'error': 'Could not lock object',
            }, status=status.HTTP_403_FORBIDDEN)
        yield instance
        if not was_locked and instance.pk is not None:
            instance.unlock(self.request.user)

    def perform_update(self, serializer):
        with self._ensure_locked(serializer.instance):
            return super().perform_update(serializer)

    def perform_destroy(self, instance):
        with self._ensure_locked(instance):
            return super().perform_destroy(instance)


class ProjectTypeViewSet(viewsets.ModelViewSet):
    queryset = ProjectType.objects.all()
    filter_backends = [filters.SearchFilter]
    search_fields = ['name']
    
    def get_serializer_class(self):
        return ProjectTypeShortSerializer if self.action == 'list' else \
               ProjectTypePreviewSerializer if self.action == 'preview' else \
               ProjectTypeDetailSerializer
    
    @action(detail=True, methods=['post'])
    def preview(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        try:
            d = serializer.data
            pdf_preview = render_pdf_preview(
                report_template=d['report_template'],
                report_styles=d['report_styles'],
                report_preview_data=d['report_preview_data'],
                project_type=instance
            )
            return FileResponse(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, url_path='predefinedfields/findings')
    def get_predefined_finding_fields(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FINDING_FIELDS_PREDEFINED))


class PentestProjectViewSet(viewsets.ModelViewSet):
    filter_backends = [filters.SearchFilter]
    search_fields = ['name']

    def get_serializer_class(self):
        return PentestProjectShortSerializer if self.action in ['list', 'create', 'metadata'] else \
               PublishPdfOptionsSerializer if self.action in ['generate'] else \
               PentestProjectDetailSerializer

    def get_queryset(self):
        return PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('report', 'project_type')

    @action(detail=True, methods=['post'])
    def preview(self, request, *args, **kwargs):
        instance = self.get_object()
        try:
            pdf_preview = render_pdf(project_type=instance.project_type, project=instance)
            return FileResponse(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def check(self, request, *args, **kwargs):
        instance = self.get_object()
        res = instance.report.perform_checks()
        return Response(data=format_messages(res))
    
    @action(detail=True, methods=['post'])
    def generate(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data)
        serializer.is_valid(raise_exception=True)
        options = serializer.validated_data

        # Check for errors
        if (messages := format_messages(instance.report.perform_checks())) and messages.get(MessageLevel.ERROR.value):
            return Response(data=messages, status=status.HTTP_400_BAD_REQUEST)
        
        # Generate final report; optionally encrypt PDF if a password was supplied
        try:
            pdf = render_pdf(project_type=instance.project_type, project=instance)
            pdf = post_process_pdf(pdf, password=options.get('password'))
            return FileResponse(BytesIO(pdf), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)


class PentestFindingViewSet(LockableViewSetMixin, viewsets.ModelViewSet):
    pagination_class = None

    def get_serializer_class(self):
        return PentestFindingFromTemplateSerializer if self.action == 'fromtemplate' else \
               PentestFindingSerializer

    @functools.cache
    def get_project(self):
        return PentestProject.objects.select_related('project_type', 'report').get(pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def get_queryset(self):
        return PentestFinding.objects \
            .only_permitted(self.request.user) \
            .filter(report__project=self.kwargs['project_pk']) \
            .select_related('report__project__project_type', 'lock_info_data', 'lock_info_data__user')

    @action(detail=False, methods=['post'])
    def fromtemplate(self, request, *args, **kwargs):
        return super().create(request, *args, **kwargs)



class ReportSectionViewSet(LockableViewSetMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet):
    serializer_class = ReportSectionSerializer
    pagination_class = None

    def get_project(self):
        return get_object_or_404(
            PentestProject.objects \
                .only_permitted(self.request.user) \
                .select_related('project_type', 'report'),
            pk=self.kwargs['project_pk'])

    def get_queryset(self):
        return self.get_project().report.sections
    
    def get_object(self):
        sections = self.get_queryset()

        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        obj = [s for s in sections if s.id == self.kwargs[lookup_url_kwarg]]
        if obj:
            obj = obj[0]
        else:
            raise Http404()

        # May raise a permission denied
        self.check_object_permissions(self.request, obj)

        return obj

    def list(self, *args, **kwargs):
        serializer = self.get_serializer(self.get_queryset(), many=True)
        return Response(serializer.data)


class UploadedFileViewSetMixin:
    permission_classes = [IsAuthenticatedOrRetrieve]
    pagination_class = None

    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        return FileResponse(instance.file.open())

    @action(detail=False, url_path='name/(?P<filename>[^/]+)')
    def retrieve_by_name(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())
        instance = get_object_or_404(queryset, name=kwargs['filename'])
        self.check_object_permissions(request, instance)
        return FileResponse(instance.file.open())


class UploadedImageViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedImageSerializer

    def get_queryset(self):
        qs = UploadedImage.objects \
            .filter(linked_object=self.kwargs['project_pk'])
        if not self.request.user.is_anonymous:
            qs = qs.only_permitted(self.request.user)
        return qs

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': PentestProject.objects.get(pk=self.kwargs['project_pk']),
        }


class UploadedAssetViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedAssetSerializer

    def get_queryset(self):
        return UploadedAsset.objects \
            .filter(linked_object=self.kwargs['projecttype_pk'])
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project_type': ProjectType.objects.get(pk=self.kwargs['projecttype_pk']),
        }



class FindingTemplatePagination(CursorPagination):
    ordering = ['-usage_count', '-risk_score', '-created']


class FindingTemplateViewSet(LockableViewSetMixin, viewsets.ModelViewSet):
    queryset = FindingTemplate.objects.all()
    serializer_class = FindingTemplateSerializer
    filter_backends = [filters.SearchFilter]
    search_fields = ['title', 'tags']
    pagination_class = FindingTemplatePagination

    def paginate_queryset(self, queryset):
        return super().paginate_queryset(queryset)

    @action(detail=False)
    def fielddefinition(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FindingTemplate.field_definition))

