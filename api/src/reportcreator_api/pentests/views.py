import contextlib
import functools
from io import BytesIO
from django.http import FileResponse, Http404
from django.shortcuts import get_object_or_404
from django.db import transaction
from django.core.files.base import ContentFile
from rest_framework import viewsets, mixins, status, filters
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.pagination import CursorPagination
from rest_framework.settings import api_settings
from django_filters.rest_framework import DjangoFilterBackend

from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_PREDEFINED
from reportcreator_api.pentests.customfields.types import field_definition_to_dict
from reportcreator_api.pentests.models import FindingTemplate, LockStatus, PentestFinding, PentestProject, ProjectType, ReportSection, UploadedAsset, UploadedImage
from reportcreator_api.pentests.permissions import IsAuthenticatedOrRetrieve, IsDesignerOrReadOnly, IsTemplateEditorOrReadOnly, SendBeaconAuthentication
from reportcreator_api.pentests.render import PdfRenderingError, post_process_pdf, render_pdf, render_pdf_preview
from reportcreator_api.pentests.serializers import FindingTemplateSerializer, PentestFindingFromTemplateSerializer, PentestFindingSerializer, PentestProjectSerializer, PreviewPdfOptionsSerializer, ProjectTypeDetailSerializer, ProjectTypePreviewSerializer, ProjectTypeShortSerializer, PublishPdfOptionsSerializer, ReportSectionSerializer, UploadedAssetSerializer, UploadedImageSerializer
from reportcreator_api.utils.error_messages import MessageLevel, format_messages


class LockableViewSetMixin:
    @action(detail=True, methods=['post'])
    def lock(self, request, *args, **kwargs):
        instance = self.get_object()
        
        lock_status = instance.lock(request.user, refresh_lock=request.data.get('refresh_lock', True))
        serializer = self.get_serializer(instance)
        return Response(serializer.data, status={
            LockStatus.CREATED: status.HTTP_201_CREATED,
            LockStatus.REFRESHED: status.HTTP_200_OK,
            LockStatus.FAILED: status.HTTP_403_FORBIDDEN
        }[lock_status])

    @action(detail=True, methods=['post'], authentication_classes=[SendBeaconAuthentication] + api_settings.DEFAULT_AUTHENTICATION_CLASSES, permission_classes=[])
    def unlock(self, request, *args, **kwargs):
        instance = self.get_object()
        if not instance.unlock(request.user):
            return Response({
                'error': 'Could not unlock object'
            }, status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(instance)
        return Response(serializer.data)

    @contextlib.contextmanager
    def _ensure_locked(self, instance):
        was_locked = instance.is_locked
        if not instance.lock(self.request.user):
            return Response({
                'error': 'Could not lock object',
            }, status=status.HTTP_403_FORBIDDEN)
        yield instance
        if not was_locked and instance.pk is not None:
            instance.unlock(self.request.user)

    def perform_update(self, serializer):
        with self._ensure_locked(serializer.instance):
            return super().perform_update(serializer)

    def perform_destroy(self, instance):
        with self._ensure_locked(instance):
            return super().perform_destroy(instance)


class CopyViewSetMixin:
    @action(detail=True, methods=['post'])
    def copy(self, request, *args, **kwargs):
        instance = self.get_object().copy()
        serializer = self.get_serializer(instance)
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class ProjectTypeViewSet(LockableViewSetMixin, CopyViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsDesignerOrReadOnly]
    queryset = ProjectType.objects.all()
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['name']
    filterset_fields = ['language']
    
    def get_serializer_class(self):
        return ProjectTypeShortSerializer if self.action == 'list' else \
               ProjectTypePreviewSerializer if self.action == 'preview' else \
               ProjectTypeDetailSerializer
    
    @action(detail=True, methods=['post'])
    def preview(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        try:
            d = serializer.data
            pdf_preview = render_pdf_preview(
                report_template=d['report_template'],
                report_styles=d['report_styles'],
                report_preview_data=d['report_preview_data'] or {},
                project_type=instance
            )
            return FileResponse(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, url_path='predefinedfields/findings')
    def get_predefined_finding_fields(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FINDING_FIELDS_PREDEFINED))


class PentestProjectViewSet(CopyViewSetMixin, viewsets.ModelViewSet):
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['name']
    filterset_fields = ['language']

    def get_serializer_class(self):
        return PublishPdfOptionsSerializer if self.action in ['generate'] else \
               PreviewPdfOptionsSerializer if self.action in ['preview'] else \
               PentestProjectSerializer

    def get_queryset(self):
        return PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('report', 'project_type')

    @action(detail=True, methods=['post'])
    def preview(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data)
        serializer.is_valid(raise_exception=True)
        options = serializer.validated_data

        try:
            pdf_preview = render_pdf(project_type=options.get('project_type') or instance.project_type, project=instance)
            return FileResponse(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def check(self, request, *args, **kwargs):
        instance = self.get_object()
        res = instance.report.perform_checks()
        return Response(data=format_messages(res))
    
    @action(detail=True, methods=['post'])
    def generate(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data)
        serializer.is_valid(raise_exception=True)
        options = serializer.validated_data

        # Check for errors
        if (messages := format_messages(instance.report.perform_checks())) and messages.get(MessageLevel.ERROR.value):
            return Response(data=messages, status=status.HTTP_400_BAD_REQUEST)
        
        # Generate final report; optionally encrypt PDF if a password was supplied
        try:
            pdf = render_pdf(project_type=options.get('project_type') or instance.project_type, project=instance)
            pdf = post_process_pdf(pdf, password=options.get('password'))
            return FileResponse(BytesIO(pdf), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)


class PentestFindingViewSet(LockableViewSetMixin, viewsets.ModelViewSet):
    pagination_class = None

    def get_serializer_class(self):
        return PentestFindingFromTemplateSerializer if self.action == 'fromtemplate' else \
               PentestFindingSerializer

    @functools.cache
    def get_project(self):
        return PentestProject.objects.select_related('project_type', 'report').get(pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def get_queryset(self):
        return PentestFinding.objects \
            .only_permitted(self.request.user) \
            .filter(report__project=self.kwargs['project_pk']) \
            .select_related('report__project__project_type', 'lock_info_data', 'lock_info_data__user')

    @action(detail=False, methods=['post'])
    def fromtemplate(self, request, *args, **kwargs):
        return super().create(request, *args, **kwargs)


class ReportSectionViewSet(LockableViewSetMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet):
    serializer_class = ReportSectionSerializer
    pagination_class = None
    lookup_field = 'section_id'

    def get_queryset(self):
        qs = ReportSection.objects \
            .only_permitted(self.request.user) \
            .filter(report__project__id=self.kwargs['project_pk']) \
            .select_related('report', 'report__project', 'report__project__project_type')
        if self.request.method in ['PUT', 'PATCH']:
            # Lock report with select_for_update because all section fields of a report are stored in the same DB entity (report).
            # Locking does not prevent race conditions on updating because multiple locks can exist for the same DB object.
            # Therefore updates need to be serialized with select_for_update such that no race conditions occur.
            qs = qs.select_for_update(of=['self', 'report'])
        return qs

    def list(self, *args, **kwargs):
        sections = self.get_queryset()
        # Sort sections
        if sections:
            section_order = [s.get('id') for s in sections[0].project_type.report_sections]
            sections = sorted(sections, key=lambda s: section_order.index(str(s.section_id)))

        serializer = self.get_serializer(sections, many=True)
        return Response(serializer.data)

    def update(self, request, *args, **kwargs):
        with transaction.atomic():
            return super().update(request, *args, **kwargs)


class UploadedFileViewSetMixin:
    permission_classes = [IsAuthenticatedOrRetrieve]
    pagination_class = None

    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        return FileResponse(instance.file.open())

    @action(detail=False, url_path='name/(?P<filename>[^/]+)')
    def retrieve_by_name(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())
        instance = get_object_or_404(queryset, name=kwargs['filename'])
        self.check_object_permissions(request, instance)
        return FileResponse(instance.file.open())


class UploadedImageViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedImageSerializer

    def get_queryset(self):
        qs = UploadedImage.objects \
            .filter(linked_object=self.kwargs['project_pk'])
        if not self.request.user.is_anonymous:
            qs = qs.only_permitted(self.request.user)
        return qs

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': PentestProject.objects.get(pk=self.kwargs['project_pk']),
        }


class UploadedAssetViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = UploadedFileViewSetMixin.permission_classes + [IsDesignerOrReadOnly]
    serializer_class = UploadedAssetSerializer

    def get_queryset(self):
        return UploadedAsset.objects \
            .filter(linked_object=self.kwargs['projecttype_pk'])
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project_type': ProjectType.objects.get(pk=self.kwargs['projecttype_pk']),
        }


class FindingTemplatePagination(CursorPagination):
    ordering = ['-usage_count', '-risk_score', '-created']


class FindingTemplateViewSet(LockableViewSetMixin, viewsets.ModelViewSet):
    queryset = FindingTemplate.objects.all()
    serializer_class = FindingTemplateSerializer
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['title', 'tags', 'language']
    filterset_fields = ['language']
    pagination_class = FindingTemplatePagination
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsTemplateEditorOrReadOnly]

    def paginate_queryset(self, queryset):
        return super().paginate_queryset(queryset)

    @action(detail=False)
    def fielddefinition(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FindingTemplate.field_definition))

