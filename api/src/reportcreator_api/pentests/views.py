import contextlib
import functools
from io import BytesIO
import itertools
import operator
from django.http import FileResponse, StreamingHttpResponse
from django.shortcuts import get_object_or_404
from django.db import transaction
from django.db.models import Prefetch, Q
from django.utils import timezone
from rest_framework import viewsets, mixins, status, exceptions
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.pagination import CursorPagination
from rest_framework.serializers import Serializer
from rest_framework.filters import OrderingFilter, SearchFilter
from rest_framework.settings import api_settings
from django_filters.rest_framework import DjangoFilterBackend, FilterSet, BooleanFilter, MultipleChoiceFilter, UUIDFilter

from reportcreator_api.utils.api import FileResponseAsync, GenericAPIViewAsync
from reportcreator_api.archive.import_export import export_project_types, export_projects, export_templates, import_project_types, import_projects, import_templates
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_PREDEFINED
from reportcreator_api.pentests.customfields.types import field_definition_to_dict
from reportcreator_api.pentests.models import FindingTemplate, LockStatus, NotebookPage, PentestFinding, PentestProject, ProjectType, ProjectTypeScope, ReportSection, SourceEnum, \
    UploadedAsset, UploadedImage, ProjectMemberInfo, UploadedProjectFile, UploadedUserNotebookImage
from reportcreator_api.pentests.permissions import IsTemplateEditorOrReadOnly, ProjectPermissions, \
    ProjectSubresourcePermissions, ProjectTypePermissions, ProjectTypeSubresourcePermissions
from reportcreator_api.tasks.rendering.entry import PdfRenderingError, render_pdf, render_pdf_preview
from reportcreator_api.pentests.serializers import CopySerializer, FindingTemplateSerializer, ImportSerializer, NotebookPageSerializer, \
    PentestFindingFromTemplateSerializer, PentestFindingSerializer, PentestProjectReadonlySerializer, PentestProjectSerializer, \
    PreviewPdfOptionsSerializer, ProjectNotebookPageCreateSerializer, NotebookPageSortListSerializer, ProjectTypeCreateSerializer, ProjectTypeDetailSerializer, \
    ProjectTypePreviewSerializer, ProjectTypeShortSerializer, ProjectTypeCopySerializer, PublishPdfOptionsSerializer, ReportSectionSerializer, \
    UploadedAssetSerializer, UploadedImageSerializer, PentestProjectCopySerializer, UploadedProjectFileSerilaizer, \
    UploadedUserNotebookImageSerializer, UserNotebookPageCreateSerializer
from reportcreator_api.utils.error_messages import MessageLevel, format_messages


class ViewSetMixinHelper:
    def get_serializer_for_action(self, action, **kwargs):
        action_bak = self.action
        try:
            self.action = action
            return self.get_serializer(**kwargs)
        finally:
            self.action = action_bak


class LockableViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action in ['lock', 'unlock']:
            return Serializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def lock(self, request, *args, **kwargs):
        instance = self.get_object()
        
        lock_status = instance.lock(request.user, refresh_lock=request.data.get('refresh_lock', True))
        instance.refresh_from_db()
        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data, status={
            LockStatus.CREATED: status.HTTP_201_CREATED,
            LockStatus.REFRESHED: status.HTTP_200_OK,
            LockStatus.FAILED: status.HTTP_403_FORBIDDEN
        }[lock_status])

    @action(detail=True, methods=['post'])
    def unlock(self, request, *args, **kwargs):
        instance = self.get_object()
        if not instance.unlock(request.user):
            raise exceptions.PermissionDenied('Could not lock object')

        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data)

    @contextlib.contextmanager
    def _ensure_locked(self, instance):
        was_locked = instance.is_locked
        if instance.lock(self.request.user, refresh_lock=False) == LockStatus.FAILED:
            raise exceptions.PermissionDenied('Could not lock object')
        yield instance
        if not was_locked and instance.pk is not None:
            instance.unlock(self.request.user)

    def perform_update(self, serializer):
        with self._ensure_locked(serializer.instance):
            return super().perform_update(serializer)

    def perform_destroy(self, instance):
        with self._ensure_locked(instance):
            return super().perform_destroy(instance)


class ExportImportViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action == 'export':
            return Serializer
        elif self.action == 'import_':
            return ImportSerializer
        else:
            return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def export(self, request, **kwargs):
        instance = self.get_object()
        archive = self.perform_export([instance])
        return StreamingHttpResponse(streaming_content=archive, headers={
            'Content-Type': 'application/octet-stream',
            'Content-Disposition': f'inline',
        })
    
    def perform_export(self, instances):
        pass

    @action(detail=False, url_path='import', url_name='import', methods=['post'])
    def import_(self, request, **kwargs):
        import_serializer = self.get_serializer(data=request.data)
        import_serializer.is_valid(raise_exception=True)

        with import_serializer.validated_data['file'].open('rb') as f:
            imported_instances = self.perform_import(f, data=import_serializer.validated_data)
        result_serializer = self.get_serializer_for_action('get', instance=imported_instances, many=True)
        return Response(result_serializer.data, status=status.HTTP_201_CREATED)
    
    def perform_import(self, archive, data):
        pass


class CopyViewSetMixin:
    def get_serializer_class(self):
        if self.action == 'copy':
            return CopySerializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def copy(self, request, *args, **kwargs):
        instance = self.get_object()
        request_serializer = self.get_serializer(instance=instance, data=request.data)
        request_serializer.is_valid(raise_exception=True)
        instance_cp = request_serializer.save()
        
        response_serializer = self.get_serializer_for_action('get', instance=instance_cp)
        return Response(response_serializer.data, status=status.HTTP_201_CREATED)


class ProjectTypeFilter(FilterSet):
    scope = MultipleChoiceFilter(label='Scopes', choices=ProjectTypeScope.choices, method='filter_scopes')
    linked_project = UUIDFilter(label='Linked project', method='filter_linked_project')

    class Meta:
        model = ProjectType
        fields = ['language']

    def filter_scopes(self, queryset, name, value):
        scope_filters = []
        for v in set(value):
            if v == 'global':
                scope_filters.append(Q(linked_project=None) & Q(linked_user=None))
            elif v == 'private':
                scope_filters.append(Q(linked_user=self.request.user))
            elif v == 'project':
                scope_filters.append(Q(linked_project__isnull=False))

        return queryset.filter(functools.reduce(operator.or_, scope_filters))

    def filter_linked_project(self, queryset, name, value):
        return queryset.filter(Q(linked_project=None) | Q(linked_project_id=value))


class ProjectTypeViewSetBase:
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectTypePermissions]
    queryset = ProjectType.objects.all()
    serializer_class = ProjectTypeDetailSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend, OrderingFilter]
    search_fields = ['name']
    filterset_class = ProjectTypeFilter
    ordering_fields = ['created', 'name']
    ordering = ['-created']
    
    def get_serializer_class(self):
        if self.action == 'list':
            return ProjectTypeShortSerializer
        elif self.action == 'create':
            return ProjectTypeCreateSerializer
        elif self.action == 'preview':
            return ProjectTypePreviewSerializer
        elif self.action == 'copy':
            return ProjectTypeCopySerializer
        return super().get_serializer_class()
    
    def get_queryset(self):
        return super().get_queryset() \
            .select_related('lock_info_data', 'lock_info_data__user', 'linked_project', 'linked_user') \
            .prefetch_related(Prefetch('linked_project__members', queryset=ProjectMemberInfo.objects.select_related('user'))) \
            .only_permitted(self.request.user)


class ProjectTypeViewSet(ProjectTypeViewSetBase, LockableViewSetMixin, CopyViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    @action(detail=False, url_path='predefinedfields/findings')
    def get_predefined_finding_fields(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FINDING_FIELDS_PREDEFINED))

    def perform_export(self, instances):
        return export_project_types(instances)
    
    def perform_import(self, archive, data):
        return import_project_types(archive)


class ProjectTypePreviewView(ProjectTypeViewSetBase, GenericAPIViewAsync):
    _action = 'preview'
    throttle_scope = 'pdf'

    async def post(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(data=request.data)

        try:
            d = serializer.validated_data
            pdf_preview = await render_pdf_preview(
                report_template=d['report_template'],
                report_styles=d['report_styles'],
                report_preview_data=d['report_preview_data'] or {},
                project_type=instance
            )
            return FileResponseAsync(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)


class PentestProjectViewSetBase:
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectPermissions]
    serializer_class = PentestProjectSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend]
    search_fields = ['name']
    filterset_fields = ['language', 'readonly']

    def get_serializer_class(self):
        if self.action == 'generate':
            return PublishPdfOptionsSerializer
        elif self.action == 'preview':
            return PreviewPdfOptionsSerializer
        elif self.action == 'readonly':
            return PentestProjectReadonlySerializer
        elif self.action == 'copy':
            return PentestProjectCopySerializer
        elif self.action == 'upload_image_or_file':
            return UploadedProjectFileSerilaizer
        elif self.action in ['customize_projecttype', 'export_all']:
            return Serializer
        return super().get_serializer_class()

    def get_queryset(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type') \
            .prefetch_related(Prefetch('members', queryset=ProjectMemberInfo.objects.select_related('user')))
        if self.action in ['check', 'preview', 'generate']:
            qs = qs.prefetch_related('sections', 'findings')
        return qs


class PentestProjectViewSet(PentestProjectViewSetBase, CopyViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    @action(detail=True, methods=['get'])
    def check(self, request, *args, **kwargs):
        instance = self.get_object()
        res = instance.perform_checks()
        return Response(data=format_messages(res))
    
    @action(detail=True, methods=['get', 'patch', 'put'])
    def readonly(self, request, *args, **kwargs):
        if request.method == 'get':
            return self.retrieve(request, *args, **kwargs)
        else:
            return self.partial_update(request, *args, **kwargs)
    
    @action(detail=True, url_path='customize-projecttype', methods=['post'])
    def customize_projecttype(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.project_type = instance.project_type.copy(
            name='Customization of ' + instance.project_type.name,
            source=SourceEnum.CUSTOMIZED,
            linked_project=instance,
            linked_user=None)
        instance.save()
        return Response(data={'project_type': instance.project_type.id})
    
    @action(detail=True, url_path='upload', methods=['post'])
    def upload_image_or_file(self, request, *args, **kwargs):
        # First try saving an image, then saving as a regular file
        serializer_context = self.get_serializer_context() | {'project': self.get_object()}
        serializer = UploadedImageSerializer(data=request.data, context=serializer_context)
        if not serializer.is_valid(raise_exception=False):
            serializer = UploadedProjectFileSerilaizer(data=request.data, context=serializer_context)
            serializer.is_valid(raise_exception=True)
        
        serializer.save()
        return Response(data=serializer.data, status=status.HTTP_201_CREATED)
 
    @action(detail=True, methods=['post'], url_path='export/all')
    def export_all(self, *args, **kwargs):
        return self.export(*args, **kwargs)
    
    def perform_export(self, instances):
        return export_projects(instances, export_all=self.action == 'export_all')
    
    def perform_import(self, archive, data):
        projects = import_projects(archive)
        PentestProject.objects.add_member(user=self.request.user, projects=projects)
        return projects


class PentestProjectPreviewView(PentestProjectViewSetBase, GenericAPIViewAsync):
    _action = 'preview'
    throttle_scope = 'pdf'

    async def post(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(instance, data=request.data)
        options = serializer.validated_data

        try:
            pdf_preview = await render_pdf(project=instance, **options)
            return FileResponseAsync(BytesIO(pdf_preview), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)


class PentestProjectGenerateView(PentestProjectViewSetBase, GenericAPIViewAsync):
    _action = 'generate'
    throttle_scope = 'pdf'

    async def post(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(instance, data=request.data)
        options = serializer.validated_data

        # Check for errors
        if (messages := format_messages(instance.perform_checks())) and messages.get(MessageLevel.ERROR.value):
            return Response(data=messages, status=status.HTTP_400_BAD_REQUEST)
        
        # Generate final report; optionally encrypt PDF if a password was supplied
        try:
            pdf = await render_pdf(project=instance, password=options.get('password'))
            return FileResponseAsync(BytesIO(pdf), content_type='application/pdf')
        except PdfRenderingError as ex:
            return Response(data=format_messages(ex.messages), status=status.HTTP_400_BAD_REQUEST)


class PentestFindingViewSet(LockableViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    serializer_class = PentestFindingSerializer
    pagination_class = None
    lookup_field = 'finding_id'

    def get_serializer_class(self):
        if self.action == 'fromtemplate':
            return PentestFindingFromTemplateSerializer
        return super().get_serializer_class()

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type')
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def get_queryset(self):
        return PentestFinding.objects \
            .only_permitted(self.request.user) \
            .filter(project=self.kwargs['project_pk']) \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')

    @action(detail=False, methods=['post'])
    def fromtemplate(self, request, *args, **kwargs):
        return super().create(request, *args, **kwargs)


class ReportSectionViewSet(LockableViewSetMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    serializer_class = ReportSectionSerializer
    pagination_class = None
    lookup_field = 'section_id'

    def get_queryset(self):
        qs = ReportSection.objects \
            .only_permitted(self.request.user) \
            .filter(project__id=self.kwargs['project_pk']) \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')
        if self.request.method in ['PUT', 'PATCH']:
            # Lock project with select_for_update because all section fields of a report are stored in the same DB entity (project).
            # Locking does not prevent race conditions on updating because multiple locks can exist for the same DB object.
            # Therefore updates need to be serialized with select_for_update such that no race conditions occur.
            qs = qs.select_for_update(of=['self', 'project'])
        return qs

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type')
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def list(self, *args, **kwargs):
        sections = self.get_queryset()
        # Sort sections
        if sections:
            section_order = [s.get('id') for s in sections[0].project_type.report_sections]
            sections = sorted(sections, key=lambda s: section_order.index(str(s.section_id)))

        serializer = self.get_serializer(sections, many=True)
        return Response(serializer.data)

    def update(self, request, *args, **kwargs):
        with transaction.atomic():
            return super().update(request, *args, **kwargs)


class NotebookPageViewSetBase(LockableViewSetMixin, viewsets.ModelViewSet):
    pagination_class = None
    lookup_field = 'note_id'
    serializer_class = NotebookPageSerializer
    create_serializer_class = None

    def get_queryset(self):
        return NotebookPage.objects \
            .select_related('parent', 'lock_info_data', 'lock_info_data__user') \
            .order_by('parent', 'order')

    def get_serializer_class(self):
        if self.action == 'sort':
            return NotebookPageSortListSerializer
        elif self.action == 'create':
            return self.create_serializer_class
        return super().get_serializer_class()
    
    @action(detail=False, methods=['post'])
    @transaction.atomic
    def sort(self, request, *arg, **kwargs):
        serializer = self.get_serializer(instance=list(self.get_queryset()), data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(data=serializer.data)


class ProjectNotebookPageViewSet(NotebookPageViewSetBase):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    create_serializer_class = ProjectNotebookPageCreateSerializer

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type')
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_queryset(self):
        return super().get_queryset() \
            .filter(project=self.get_project())
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project()
        }
    

class UserNotebookPageViewSet(NotebookPageViewSetBase):
    create_serializer_class = UserNotebookPageCreateSerializer

    def get_user(self):
        return self.request.user

    def get_queryset(self):
        return super().get_queryset() \
            .filter(user=self.get_user())
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'user': self.get_user()
        }


class UploadedFileViewSetMixin:
    @action(detail=False, url_path='name/(?P<filename>[^/]+)')
    def retrieve_by_name(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())
        instance = get_object_or_404(queryset.filter_name(kwargs['filename']))
        self.check_object_permissions(request, instance)
        return FileResponse(instance.file.open(), filename=instance.name)


class UploadedImageViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    serializer_class = UploadedImageSerializer

    def get_queryset(self):
        return UploadedImage.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.kwargs['project_pk'])

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user)
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }
    

class UploadedProjectFileViewSet(UploadedImageViewSet):
    serializer_class = UploadedProjectFileSerilaizer

    def get_queryset(self):
        return UploadedProjectFile.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.kwargs['project_pk'])
    

class UploadedUserNotebookImageViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedUserNotebookImageSerializer

    def get_user(self):
        return self.request.user

    def get_queryset(self):
        return UploadedUserNotebookImage.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.get_user())

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'user': self.get_user()
        }


class UploadedAssetViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectTypeSubresourcePermissions]
    serializer_class = UploadedAssetSerializer

    def get_queryset(self):
        return UploadedAsset.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.kwargs['projecttype_pk'])

    @functools.cache
    def get_project_type(self):
        qs = ProjectType.objects \
            .only_permitted(self.request.user) \
            .select_related('linked_project', 'linked_user') \
            .prefetch_related(Prefetch('linked_project__members', queryset=ProjectMemberInfo.objects.select_related('user')))
        return get_object_or_404(qs, pk=self.kwargs['projecttype_pk'])
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project_type': self.get_project_type(),
        }


class FindingTemplatePagination(CursorPagination):
    def get_ordering(self, request, queryset, view):
        ordering_filters = [
            filter_cls for filter_cls in getattr(view, 'filter_backends', [])
            if hasattr(filter_cls, 'get_queryset_ordering')
        ]
        if ordering_filters:
            return ordering_filters[0]().get_queryset_ordering(request, queryset, view)
        return super().get_ordering()


class FindingTemplateOrderingFilter(OrderingFilter):
    ordering_fields = ['risk', 'usage']

    def get_queryset_ordering(self, request, queryset, view):
        ordering = self.get_ordering(request, queryset, view)[0]
        if ordering == 'risk':
            return ['risk_score', 'created']
        elif ordering == '-risk':
            return ['-risk_score', '-created']
        elif ordering == 'usage':
            return ['usage_count', 'risk_score', 'created']
        elif ordering == '-usage':
            return ['-usage_count', '-risk_score', '-created']
        else:
            return None

    def filter_queryset(self, request, queryset, view):
        ordering = self.get_queryset_ordering(request, queryset, view)
        if ordering:
            return queryset.order_by(*ordering)
        return queryset

    def get_default_ordering(self, view):
        return ['-risk']


class FindingTemplateViewSet(LockableViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    queryset = FindingTemplate.objects.select_related('lock_info_data', 'lock_info_data__user').all()
    serializer_class = FindingTemplateSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend, FindingTemplateOrderingFilter]
    search_fields = ['title', 'tags', 'language']
    filterset_fields = ['language']
    pagination_class = FindingTemplatePagination
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsTemplateEditorOrReadOnly]

    def paginate_queryset(self, queryset):
        return super().paginate_queryset(queryset)

    @action(detail=False)
    def fielddefinition(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FindingTemplate.field_definition))

    def perform_export(self, instances):
        return export_templates(instances)
    
    def perform_import(self, archive, data):
        return import_templates(archive)

