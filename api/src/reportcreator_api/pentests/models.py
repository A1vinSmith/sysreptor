import enum
import itertools
from uuid import uuid4
from django.conf import settings
from django.db import models, transaction, IntegrityError
from django.utils.translation import gettext_lazy as _
from django.core.serializers.json import DjangoJSONEncoder
from django.contrib.postgres.fields import ArrayField
from django.contrib.contenttypes.models import ContentType
from django.utils import timezone
from jsonschema import ValidationError
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_CORE, FINDING_FIELDS_PREDEFINED, REPORT_FIELDS_CORE, REPORT_FIELDS_PREDEFINED, finding_field_order_default, finding_fields_default, report_fields_default, report_sections_default
from reportcreator_api.utils.error_messages import ErrorMessage
from reportcreator_api.pentests import cvss as cvss_utils, querysets, storages
from reportcreator_api.pentests.customfields.mixins import CustomFieldsMixin
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure, set_field_origin
from reportcreator_api.pentests.customfields.validators import FieldDefinitionValidator, SectionDefinitionValidator
from reportcreator_api.pentests.customfields.types import FieldDefinition, field_definition_to_dict, parse_field_definition

from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.models import BaseModel, LanguageMixin
from reportcreator_api.utils.relations import GenericOneToOneForeignKey, GenericOneToOneRelation
from reportcreator_api.utils.utils import remove_duplicates
from reportcreator_api.utils.decorators import cache


class LockStatus(enum.Enum):
    CREATED = 'created'
    REFRESHED = 'refreshed'
    FAILED = 'failed'


class LockInfo(BaseModel):
    # Generic foreign key to arbitrary/multiple models
    content_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)
    object_id = models.UUIDField()
    locked_object = GenericOneToOneForeignKey(ct_field='content_type', fk_field='object_id')

    last_ping = models.DateTimeField(default=timezone.now)
    user = models.ForeignKey(to=PentestUser, on_delete=models.CASCADE, null=False)

    class Meta:
        unique_together = [('content_type', 'object_id')]

    @property
    def expires(self):
        return (self.last_ping or timezone.now()) + settings.MAX_LOCK_TIME

    def refresh_lock(self):
        try:
            self.last_ping = timezone.now()
            self.save(force_update=True)
            return LockStatus.REFRESHED
        except self.DoesNotExist:
            return LockStatus.FAILED


class LockableMixin(models.Model):
    lock_info_data = GenericOneToOneRelation(to=LockInfo)

    class Meta:
        abstract = True

    @property
    def lock_info(self):
        if not self.is_locked:
            return None
        return self.lock_info_data

    @property
    def is_locked(self):
        return self.lock_info_data is not None and timezone.now() <= self.lock_info_data.expires

    def _cleanup_old_lock(self):
        if self.lock_info_data:
            self.lock_info_data.delete()
            self.lock_info_data = None

    def lock(self, user, refresh_lock=True):
        if self.is_locked and not self.lock_info.user == user:
            # Already locked by another user
            return LockStatus.FAILED
        elif self.is_locked and self.lock_info.user == user:
            # Refresh lock such that it does not expire
            if refresh_lock:
                return self.lock_info.refresh_lock()
            else:
                return LockStatus.REFRESHED
        elif not self.is_locked:
            with transaction.atomic():
                self._cleanup_old_lock()
                try:
                    self.lock_info_data = LockInfo.objects.create(locked_object=self, user=user)
                    return LockStatus.CREATED
                except IntegrityError:
                    self.lock_info_data = LockInfo.objects.get(content_type=ContentType.objects.get_for_model(self), object_id=self.id)
                    if self.lock_info_data.user == user:
                        return LockStatus.REFRESHED
                    else:
                        return LockStatus.FAILED
        return LockStatus.FAILED

    def unlock(self, user):
        if not self.is_locked:
            self._cleanup_old_lock()
            return True
        elif self.is_locked and self.lock_info.user == user:
            self._cleanup_old_lock()
            return True
        else:
            return False


class SourceEnum(models.TextChoices):
    CREATED = 'created', 'Created'
    IMPORTED = 'imported', 'Imported'
    IMPORTED_DEPENDENCY = 'imported_dependency', 'Imported Dependency'
    CUSTOMIZED = 'customized', 'Customized'


class ImportableMixin(models.Model):
    source = models.CharField(max_length=50, choices=SourceEnum.choices, default=SourceEnum.CREATED, db_index=True, editable=False)

    class Meta:
        abstract = True


class FindingTemplate(CustomFieldsMixin, LockableMixin, LanguageMixin, ImportableMixin, BaseModel):
    # TODO: store empty strings as None in template?
    usage_count = models.PositiveIntegerField(default=0, db_index=True)
    tags = ArrayField(
            base_field=models.CharField(max_length=255), 
            default=list, db_index=True)

    title = models.TextField(default='', db_index=True)

    cvss = models.CharField(max_length=255, default='n/a')
    risk_score = models.FloatField(default=0.0, db_index=True)
    risk_level = models.CharField(max_length=10, choices=cvss_utils.CVSSLevel.choices, default=cvss_utils.CVSSLevel.INFO, db_index=True)

    objects = models.Manager.from_queryset(querysets.FindingTemplateQueryset)()

    @classmethod
    @property
    @cache('FindingTemplate.field_definition', timeout=10)
    def field_definition(cls) -> dict[str, FieldDefinition]:
        return FINDING_FIELDS_CORE | ProjectType.objects.custom_finding_field_definitions() | FINDING_FIELDS_PREDEFINED | FINDING_FIELDS_CORE
    
    @property
    def core_field_names(self) -> list[str]:
        return list(FINDING_FIELDS_CORE.keys())
    
    def __str__(self) -> str:
        return self.title

    def save(self, *args, **kwargs):
        # Update risk score and level
        self.risk_score = cvss_utils.calculate_score(self.cvss)
        self.risk_level = cvss_utils.level_from_score(self.risk_score)

        return super().save(*args, **kwargs)


class ProjectType(LockableMixin, LanguageMixin, ImportableMixin, BaseModel):
    # TODO: how to handle NULL values => prevent/replace with default?
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)

    # PDF Template
    report_template = models.TextField(default='')
    report_styles = models.TextField(default='')
    report_preview_data = models.JSONField(encoder=DjangoJSONEncoder, default=dict)

    # Report
    report_fields = models.JSONField(encoder=DjangoJSONEncoder, validators=[FieldDefinitionValidator(core_fields=REPORT_FIELDS_CORE, predefined_fields=REPORT_FIELDS_PREDEFINED)], default=report_fields_default)
    report_sections = models.JSONField(encoder=DjangoJSONEncoder, validators=[SectionDefinitionValidator()], default=report_sections_default)

    # Findings
    finding_fields = models.JSONField(encoder=DjangoJSONEncoder, validators=[FieldDefinitionValidator(core_fields=FINDING_FIELDS_CORE, predefined_fields=FINDING_FIELDS_PREDEFINED)], default=finding_fields_default)
    finding_field_order = models.JSONField(encoder=DjangoJSONEncoder, default=finding_field_order_default)

    linked_project = models.ForeignKey(to='PentestProject', on_delete=models.SET_NULL, null=True, blank=True)

    objects = querysets.ProjectTypeManager()

    @property
    def finding_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.finding_fields)

    @property
    def report_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.report_fields)

    def __str__(self) -> str:
        return self.name

    def clean(self) -> None:
        # Validate report sections contain only defined fields
        if undefined_fields := set(itertools.chain(*map(lambda s: s['fields'], self.report_sections))) - set(self.report_fields.keys()):
            raise ValidationError(_('Unknown fields in section: %(fields)s') % {'fields': list(undefined_fields)})

        # Validate finding field order contains only defined fields
        if undefined_fields := set(self.finding_field_order) - set(self.finding_fields.keys()):
            raise ValidationError(_('Unknown fields in finding order: %(fields)s') % {'fields': list(undefined_fields)})

    def save(self, *args, **kwargs):
        # Ensure static fields are marked correctly
        self.report_fields = field_definition_to_dict(set_field_origin(self.report_fields_obj, predefined_fields=REPORT_FIELDS_CORE | REPORT_FIELDS_PREDEFINED))
        self.finding_fields = field_definition_to_dict(set_field_origin(self.finding_fields_obj, predefined_fields=FINDING_FIELDS_CORE | FINDING_FIELDS_PREDEFINED))

        # Ensure report section definition contains all fields
        section_fields = set()
        for s in self.report_sections:
            s['fields'] = remove_duplicates(s['fields'])
            section_fields |= set(s['fields'])
        report_fields = set(self.report_fields.keys())
        if missing_fields := list(report_fields - section_fields):
            others_section = [s for s in self.report_sections if s['id'] == 'other']
            if others_section:
                others_section = others_section[0]
            else:
                others_section = {
                    'id': 'other',
                    'label': 'Other',
                    'fields': [],
                }
                self.report_sections.append(others_section)
            others_section['fields'].extend(missing_fields)
        # Remove undefined fields from section definition
        for section in self.report_sections:
            for undefined_field in set(section['fields']) - report_fields:
                section['fields'].remove(undefined_field)
        
        # Ensure finding order contains all fields
        finding_fields = set(self.finding_fields.keys())
        self.finding_field_order = remove_duplicates(self.finding_field_order + list(finding_fields))
        # Remove undefined fields from finding order
        for undefined_field in set(self.finding_field_order) - finding_fields:
            self.finding_field_order.remove(undefined_field)

        # Ensure correct structure of report_preview_data
        if set(self.changed_fields).intersection({'report_preview_data', 'report_fields', 'finding_fields'}):
            report_data = self.report_preview_data.get('report')
            if not isinstance(report_data, dict):
                report_data = {}

            self.report_preview_data['report'] = report_data | ensure_defined_structure(value=report_data, definition=self.report_fields_obj, handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
            findings = self.report_preview_data.get('findings')
            if not isinstance(findings, list):
                # Generate findings with demo data
                # Static values for core fields
                findings = [
                    {'title': 'First Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L'}, 
                    {'title': 'Second Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:L'},
                ]
            self.report_preview_data['findings'] = [
                {'id': str(uuid4())} | f | ensure_defined_structure(value=f, definition=self.finding_fields_obj, handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
                for f in findings if isinstance(f, dict)
            ]
        
        return super().save(*args, **kwargs)

    def copy(self, data=None):
        return ProjectType.objects.copy(self, data)


class PentestProject(CustomFieldsMixin, LanguageMixin, ImportableMixin, BaseModel):
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)
    project_type = models.ForeignKey(to=ProjectType, on_delete=models.PROTECT)
    pentesters = models.ManyToManyField(to=PentestUser, related_name='projects')
    imported_pentesters = ArrayField(base_field=models.JSONField(encoder=DjangoJSONEncoder), default=list, blank=True)

    readonly = models.BooleanField(default=False, db_index=True)

    objects = querysets.PentestProjectManager()

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project_type.report_fields_obj

    def __str__(self) -> str:
        return self.name

    def delete(self, using=None, keep_parents=False):
        linked_project_types_to_delete = list(ProjectType.objects \
            .filter(linked_project=self) \
            .filter(source__in=[SourceEnum.IMPORTED_DEPENDENCY, SourceEnum.CUSTOMIZED]) \
            .annotate(used_by_other=models.Count('pentestproject', filter=~models.Q(pentestproject=models.F('linked_project')))) \
            .filter(used_by_other=0) \
            .values_list('id', flat=True))
        out = super().delete(using=using, keep_parents=keep_parents)
        ProjectType.objects.filter(id__in=linked_project_types_to_delete).delete()
        return out

    def copy(self, data=None):
        return PentestProject.objects.copy(self, data)

    def perform_checks(self) -> list[ErrorMessage]:
        from reportcreator_api.pentests.checks import run_checks
        return list(run_checks(self))


class ReportSection(LockableMixin, BaseModel):
    """
    This model stores section related meta information in the DB.
    The actual section data is stored in project.custom_fields.
    Storing everything in the ReportSection DB model would require complex manipulation of model data when section definitions change 
    (e.g. field moved to another section, field deleted form definition => keep value of section, etc.).
    But storing per-section information (e.g. locking, status tracking and assigning pentesters) is easier on a DB object.
    Therefore some parts are stored in a separate model (everything that is not influenced by section and field definition), 
    but the data still remains in the project.data JSON object.
    """
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='sections')
    section_id = models.CharField(max_length=255, null=False, db_index=True, editable=False)

    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)

    objects = models.Manager.from_queryset(querysets.ReportSectionQueryset)()

    class Meta(BaseModel.Meta):
        unique_together = [('project', 'section_id')]

    @property
    def project_type(self):
        return self.project.project_type

    @property
    def section_definition(self):
        return next(filter(lambda s: s.get('id') == self.section_id, self.project_type.report_sections), {})

    @property
    def section_label(self):
        return self.section_definition.get('label') or ''
    
    @property
    def section_fields(self):
        return self.section_definition.get('fields', [])

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return {f: self.project_type.report_fields_obj.get(f) for f in self.section_fields}
    
    @property
    def data(self):
        report_data = self.project.data
        return {f: report_data.get(f) for f in self.section_fields}

    @property
    def language(self):
        return self.project.language

    def update_data(self, value):
        self.project.update_data(value)


class PentestFinding(CustomFieldsMixin, LockableMixin, BaseModel):
    finding_id = models.UUIDField(default=uuid4, db_index=True, editable=False)
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='findings')

    title = models.TextField(default='', db_index=True)

    cvss = models.CharField(max_length=255, default='n/a')
    risk_score = models.FloatField(default=0.0, db_index=True)
    risk_level = models.CharField(max_length=10, choices=cvss_utils.CVSSLevel.choices, default=cvss_utils.CVSSLevel.INFO, db_index=True)

    template = models.ForeignKey(to=FindingTemplate, on_delete=models.SET_NULL, null=True, blank=True)
    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)

    objects = models.Manager.from_queryset(querysets.PentestFindingQueryset)()

    class Meta(BaseModel.Meta):
        ordering = ['-risk_score'] + BaseModel.Meta.ordering
        unique_together = [('project', 'finding_id')]

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project.project_type.finding_fields_obj

    @property
    def core_field_names(self) -> list[str]:
        return list(FINDING_FIELDS_CORE.keys())

    @property
    def language(self):
        return self.project.language

    def __str__(self) -> str:
        return self.title
    
    def save(self, *args, **kwargs):
        # Update risk score and level
        self.risk_score = cvss_utils.calculate_score(self.cvss)
        self.risk_level = cvss_utils.level_from_score(self.risk_score)

        return super().save(*args, **kwargs)


class UploadedFileBase(BaseModel):
    file = models.FileField()
    name = models.CharField(max_length=255, db_index=True)
    uploaded_by = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True)

    class Meta(BaseModel.Meta):
        abstract = True
        unique_together = [['linked_object', 'name']]


class UploadedImage(UploadedFileBase):
    file = models.ImageField(storage=storages.get_uploaded_image_storage)
    linked_object = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, related_name='images')

    objects = querysets.UploadedImageManager()  


class UploadedAsset(UploadedFileBase):
    file = models.FileField(storage=storages.get_uploaded_asset_storage)
    linked_object = models.ForeignKey(to=ProjectType, on_delete=models.CASCADE, related_name='assets')

    objects = querysets.UploadedAssetManager() 
