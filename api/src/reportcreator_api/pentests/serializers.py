from rest_framework import serializers
from django.db import transaction
from django.db.models import F
from reportcreator_api.pentests.customfields.serializers import serializer_from_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, check_definitions_compatible, ensure_defined_structure
from reportcreator_api.pentests.models import FindingTemplate, LockInfo, NotebookPage, PentestFinding, PentestProject, ProjectType, ReportSection, \
    UploadedAsset, UploadedImage, ProjectMemberInfo, ProjectMemberRole, UploadedProjectFile, UploadedUserNotebookImage
from reportcreator_api.users.serializers import PentestUserSerializer, RelatedUserSerializer
from reportcreator_api.utils.files import compress_image
from reportcreator_api.utils.utils import omit_items


class LockInfoSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    def __init__(self, *args, **kwargs):
        kwargs['read_only'] = True
        super().__init__(*args, **kwargs)
    
    class Meta:
        model = LockInfo
        fields = [
            'created', 'updated', 'last_ping', 'expires', 'user',
        ]
        read_only_fields = ['last_ping']


class ProjectTypeShortSerializer(serializers.ModelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='projecttype-detail', read_only=True)
    assets = serializers.HyperlinkedIdentityField(view_name='uploadedasset-list', lookup_url_kwarg='projecttype_pk', read_only=True)  

    class Meta:
        model = ProjectType
        fields = [
            'id', 'created', 'updated', 'source',
            'name', 'language',
            'details', 'assets',
        ]


class ProjectTypeDetailSerializer(ProjectTypeShortSerializer):
    lock_info = LockInfoSerializer()
    report_template = serializers.CharField(required=False, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_blank=True)
    report_preview_data = serializers.DictField(required=False)

    class Meta(ProjectTypeShortSerializer.Meta):
        fields = ProjectTypeShortSerializer.Meta.fields + [
            'lock_info',
            'report_template', 'report_styles', 'report_preview_data',
            'report_fields', 'report_sections',
            'finding_fields', 'finding_field_order',
        ]


class ProjectTypePreviewSerializer(serializers.ModelSerializer):
    report_template = serializers.CharField(required=False, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_blank=True)
    report_preview_data = serializers.DictField(required=False)

    class Meta:
        model = ProjectType
        fields = ['report_template', 'report_styles', 'report_preview_data']


class ProjectTypeCopySerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjectType
        fields = ['name']
        extra_kwargs = {'name': {'required': False}}


class ProjectTypeRelatedField(serializers.PrimaryKeyRelatedField):
    def get_queryset(self):
        return ProjectType.objects.only_permitted(self.context['request'].user)


class PentestFindingSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='finding_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = ProjectTypeRelatedField(source='project.project_type_id', read_only=True)
    lock_info = LockInfoSerializer(read_only=True)
    template = serializers.PrimaryKeyRelatedField(read_only=True, source='template_id')
    assignee = RelatedUserSerializer(required=False, allow_null=True, default=serializers.CreateOnlyDefault(serializers.CurrentUserDefault()))

    class Meta:
        model = PentestFinding
        fields = [
            'id', 'created', 'updated', 'project', 'project_type', 
            'language', 'lock_info', 'template', 'assignee', 'status',
        ]

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=self.context['project'].project_type.finding_fields_obj, **self.get_extra_kwargs().get('data', {})),
        }

    def create(self, validated_data):
        data = ensure_defined_structure(
            value=validated_data.pop('data', {}), 
            definition=self.context['project'].project_type.finding_fields_obj, 
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
        )
        instance = PentestFinding(
            project=self.context['project'], 
            **validated_data
        )
        instance.update_data(data)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class PentestFindingFromTemplateSerializer(PentestFindingSerializer):
    template = serializers.PrimaryKeyRelatedField(queryset=FindingTemplate.objects.all(), required=True, allow_null=False, source='template_id')

    class Meta(PentestFindingSerializer.Meta):
        read_only_fields = ['data']

    @transaction.atomic()
    def create(self, validated_data):
        template = validated_data.pop('template_id')
        finding = super().create(validated_data | {
            'template_id': template.id,
            'data': template.data | validated_data.pop('data', {}),
        })
        FindingTemplate.objects.filter(id=template.id).increment_usage_count()
        return finding


class ProjectMemberInfoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjectMemberInfo
        fields = ['roles']
    
    def __init__(self, user_serializer=PentestUserSerializer, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.user_serializer = user_serializer

    def get_related_user_serializer(self):
        s = RelatedUserSerializer(user_serializer=self.user_serializer)
        s.bind('user', self)
        return s

    def to_representation(self, instance):
        return self.get_related_user_serializer().to_representation(instance.user) | \
            super().to_representation(instance)

    def to_internal_value(self, data):
        return super().to_internal_value(data) | {
            'user': self.get_related_user_serializer().to_internal_value(data)
        }


class ImportedProjectMemberInfoSerializer(serializers.ModelSerializer):
    roles = serializers.ListField(child=serializers.CharField(), allow_empty=True)

    class Meta(PentestUserSerializer.Meta):
        fields = omit_items(PentestUserSerializer.Meta.fields, ['username']) + ['roles']
        extra_kwargs = {
            'id': {'read_only': False},
        }


class ImportedProjectMemberInfoListSerializer(serializers.ListSerializer):
    child = ImportedProjectMemberInfoSerializer()

    def update(self, instance, validated_data):
        updated = []
        for d in validated_data:
            i = next(filter(lambda e: str(e.get('id')) == str(d.get('id')), instance), {})
            updated.append(i | d)
        return updated


class PentestProjectSerializer(serializers.ModelSerializer):
    project_type = ProjectTypeRelatedField()
    force_change_project_type = serializers.BooleanField(required=False, default=False, write_only=True)

    members = ProjectMemberInfoSerializer(many=True, required=False)
    imported_members = ImportedProjectMemberInfoListSerializer(required=False)

    details = serializers.HyperlinkedIdentityField(view_name='pentestproject-detail', read_only=True)
    findings = serializers.HyperlinkedIdentityField(view_name='finding-list', lookup_url_kwarg='project_pk', read_only=True)
    sections = serializers.HyperlinkedIdentityField(view_name='section-list', lookup_url_kwarg='project_pk', read_only=True)
    notes = serializers.HyperlinkedIdentityField(view_name='projectnotebookpage-list', lookup_url_kwarg='project_pk', read_only=True)
    images = serializers.HyperlinkedIdentityField(view_name='uploadedimage-list', lookup_url_kwarg='project_pk', read_only=True)

    class Meta:
        model = PentestProject
        fields = [
            'id', 'created', 'updated',
            'name', 'project_type', 'force_change_project_type', 'language', 'readonly', 'source',
            'members', 'imported_members',
            'details', 'findings', 'sections', 'notes', 'images',
        ]
        read_only_fields = ['readonly']

    def validate_project_type(self, value):
        if self.instance and self.instance.project_type != value and not self.initial_data.get('force_change_project_type'):
            res_finding = check_definitions_compatible(self.instance.project_type.finding_fields_obj, value.finding_fields_obj, path=('finding_fields',))
            res_report = check_definitions_compatible(self.instance.project_type.report_fields_obj, value.report_fields_obj, path=('report_fields',))
            if not res_finding[0] or not res_report[0]:
                raise serializers.ValidationError(['Designs have incompatible field definitions. Converting might result in data loss.'] + res_report[1] + res_finding[1])
        
        return value

    @transaction.atomic
    def create(self, validated_data):
        project_type = validated_data.get('project_type')
        validated_data.pop('force_change_project_type')

        members = validated_data.pop('members', [])

        project = super().create(validated_data | {
            'language': project_type.language,
            'custom_fields': ensure_defined_structure(
                value={
                    'title': validated_data.get('name', 'Report Title'),
                }, 
                definition=validated_data['project_type'].report_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
            ),
        })

        # add current user as member
        if not any(map(lambda m: m.get('user') == self.context['request'].user, members)):
            members.append({'user': self.context['request'].user, 'roles': ProjectMemberRole.default_roles})

        for m in members:
            m.project = project
        ProjectMemberInfo.objects.bulk_create([ProjectMemberInfo(**m, project=project) for m in members])

        return project
    
    def update(self, instance, validated_data):
        members = validated_data.pop('members', None)
        instance = super().update(instance, validated_data | {
            'imported_members': self.fields['imported_members'].update(instance.imported_members, validated_data.get('imported_members', [])),
        })
        PentestProject.objects.set_members(instance=instance, members=[ProjectMemberInfo(**m) for m in members])
        return instance
        


class ReportSectionSerializer(serializers.ModelSerializer):
    id = serializers.CharField(source='section_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = ProjectTypeRelatedField(source='project.project_type_id', read_only=True)
    label = serializers.CharField(source='section_label', read_only=True)
    fields = serializers.ListField(source='section_fields', child=serializers.CharField(), read_only=True)
    lock_info = LockInfoSerializer()
    assignee = RelatedUserSerializer(required=False, allow_null=True)

    class Meta:
        model = ReportSection
        fields = [
            'id', 'label', 'fields', 'project', 'project_type', 
            'language', 'lock_info', 'assignee', 'status',
        ]
    
    def get_fields(self):
        fields = super().get_fields()
        data_field = serializers.DictField()
        if self.instance and isinstance(self.instance, ReportSection):
            data_field = serializer_from_definition(definition=self.instance.field_definition, **self.get_extra_kwargs().get('data', {}))
        return fields | {
            'data': data_field
        }

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        instance.project.save()
        return super().update(instance, validated_data)


class FindingTemplateSerializer(serializers.ModelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='findingtemplate-detail', read_only=True)
    lock_info = LockInfoSerializer()

    class Meta:
        model = FindingTemplate
        fields = [
            'id', 'created', 'updated', 'details', 
            'lock_info', 'usage_count', 'source',
            'tags', 'language', 'status', 
        ]
        read_only_fields = ['usage_count']
        extra_kwargs = {
            'tags': {'required': False, 'allow_empty': True}
        }

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=FindingTemplate.field_definition),
        }

    def create(self, validated_data):
        data = validated_data.pop('data', {})
        instance = FindingTemplate(**validated_data)
        instance.update_data(data)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class NotebookPageSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='note_id', read_only=True)
    lock_info = LockInfoSerializer()
    title = serializers.CharField(required=False, allow_blank=True)
    text = serializers.CharField(required=False, allow_blank=True)
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True, read_only=True)

    class Meta:
        model = NotebookPage
        fields = [
            'id', 'created', 'updated', 'lock_info',
            'title', 'text', 'checked', 'icon_emoji', 'status_emoji',
            'order', 'parent',
        ]
        extra_kwargs = {
            'order': {'read_only': True},
        }


class NotebookPageCreateSerializer(NotebookPageSerializer):
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True, required=False)
    
    class Meta(NotebookPageSerializer.Meta):
        extra_kwargs = {
            'order': {'read_only': False, 'required': False, 'allow_null': True},
        }

    def get_notebook_object(self):
        return None
    
    def validate_parent(self, value):
        if value:
            parent = NotebookPage.objects \
                .filter(**self.get_notebook_object()) \
                .filter(note_id=value) \
                .first()
            if not parent:
                raise serializers.ValidationError('Invalid note id')
            return parent
        return value

    @transaction.atomic()
    def create(self, validated_data):
        validated_data['parent'] = validated_data.get('parent', {}).get('note_id')

        if validated_data.get('order'):
            NotebookPage.objects \
                .filter(**self.get_notebook_object()) \
                .filter(parent=validated_data.get('parent')) \
                .filter(order__gte=validated_data.get('order')) \
                .update(order=F('order') + 1)
        else:
            validated_data.pop('order', None)

        return super().create(validated_data | self.get_notebook_object())


class ProjectNotebookPageCreateSerializer(NotebookPageCreateSerializer):
    def get_notebook_object(self):
        return {'project': self.context['project']}


class UserNotebookPageCreateSerializer(NotebookPageCreateSerializer):
    def get_notebook_object(self):
        return {'user': self.context['user']}


class NotebookPageSortSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='note_id')
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True)

    class Meta:
        model = NotebookPage
        fields = ['id', 'parent', 'order']
    
    def validate_id(self, value):
        if not next(filter(lambda n: n.note_id == value, self.parent.instance), None):
            raise serializers.ValidationError('Invalid note id')
        return value
        
    def validate_parent(self, value):
        parent = next(filter(lambda n: n.note_id == value, self.parent.instance), None)
        if value is not None and not parent:
            raise serializers.ValidationError('Invalid note id')
        return parent


class NotebookPageSortListSerializer(serializers.ListSerializer):
    def __init__(self, *args, **kwargs):
        super().__init__(child=NotebookPageSortSerializer(), *args, **kwargs)

    def update(self, instance, validated_data):
        # Update values
        missing_notes = []
        for note in instance:
            if data := next(filter(lambda d: note.note_id == d.get('note_id'), validated_data), None):
                note.parent = data.get('parent', {}).get('note_id')
                note.order = data.get('order')
            else:
                missing_notes.append(note)

        NotebookPage.objects.check_parent_and_order(instance, missing_notes)
        NotebookPage.objects.bulk_update(instance, ['parent_id', 'order'])
        return instance


class UploadedFileSerilaizerBase(serializers.ModelSerializer):
    compress_images = True

    resource_type = serializers.SerializerMethodField()

    class Meta:
        fields = ['id', 'created', 'updated', 'resource_type', 'name', 'file']
        extra_kwargs = {
            'file': {'write_only': True}, 
            'name': {'required': False},
        }

    def get_resource_type(self, obj):
        return None

    def get_linked_object(self):
        return None

    def create(self, validated_data):
        if self.compress_images:
            validated_data['file'], validated_data['name'] = compress_image(validated_data['file'], validated_data.get('name'))
        validated_data['linked_object'] = self.get_linked_object()
        validated_data['uploaded_by'] = self.context['request'].user
        return super().create(validated_data)


class UploadedImageSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedImage

    def get_linked_object(self):
        return self.context['project']
    
    def get_resource_type(self, obj):
        return 'image'


class UploadedUserNotebookImageSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedUserNotebookImage

    def get_linked_object(self):
        return self.context['user']
    
    def get_resource_type(self, obj):
        return 'user-notebook-image'


class UploadedAssetSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedAsset
    
    def get_linked_object(self):
        return self.context['project_type']
    
    def get_resource_type(self, obj):
        return 'asset'
    

class UploadedProjectFileSerilaizer(UploadedFileSerilaizerBase):
    compress_images = False

    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedProjectFile
    
    def get_linked_object(self):
        return self.context['project']
    
    def get_resource_type(self, obj):
        return 'file'


class PreviewPdfOptionsSerializer(serializers.Serializer):
    project_type = ProjectTypeRelatedField(required=False, allow_null=True)
    report_template = serializers.CharField(required=False, allow_null=True, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_null=True, allow_blank=True)


class PublishPdfOptionsSerializer(serializers.Serializer):
    password = serializers.CharField(required=False, allow_null=True, allow_blank=True)


class ImportSerializer(serializers.Serializer):
    file = serializers.FileField()


class PentestProjectReadonlySerializer(serializers.ModelSerializer):
    class Meta:
        model = PentestProject
        fields = ['readonly']


class ProjectTypeCopySerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjectType
        fields = ['name']
        extra_kwargs = {'name': {'required': False}}


class PentestProjectCopySerializer(serializers.ModelSerializer):
    project_type = ProjectTypeRelatedField(required=False)

    class Meta:
        model = PentestProject
        fields = ['name', 'project_type']
        extra_kwargs = {'name': {'required': False}}

