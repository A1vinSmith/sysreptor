from rest_framework import serializers
from django.db import transaction
from reportcreator_api.pentests.customfields.serializers import serializer_from_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, check_definitions_compatible, ensure_defined_structure
from reportcreator_api.pentests.models import FindingTemplate, LockInfo, PentestFinding, PentestProject, ProjectType, ReportSection, UploadedAsset, UploadedImage
from reportcreator_api.users.serializers import ImportedPentestUserSerializer, PentestUserSerializer, RelatedUserSerializer
from reportcreator_api.utils.files import compress_image


class LockInfoSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    def __init__(self, *args, **kwargs):
        kwargs['read_only'] = True
        super().__init__(*args, **kwargs)
    
    class Meta:
        model = LockInfo
        fields = [
            'created', 'updated', 'last_ping', 'expires', 'user',
        ]
        read_only_fields = ['last_ping']


class ProjectTypeShortSerializer(serializers.ModelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='projecttype-detail', read_only=True)
    assets = serializers.HyperlinkedIdentityField(view_name='uploadedasset-list', lookup_url_kwarg='projecttype_pk', read_only=True)  

    class Meta:
        model = ProjectType
        fields = [
            'id', 'created', 'updated', 'source',
            'name', 'language',
            'details', 'assets',
        ]


class ProjectTypeDetailSerializer(ProjectTypeShortSerializer):
    lock_info = LockInfoSerializer()
    report_template = serializers.CharField(required=False, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_blank=True)
    report_preview_data = serializers.DictField(required=False)

    class Meta(ProjectTypeShortSerializer.Meta):
        fields = ProjectTypeShortSerializer.Meta.fields + [
            'lock_info',
            'report_template', 'report_styles', 'report_preview_data',
            'report_fields', 'report_sections',
            'finding_fields', 'finding_field_order',
        ]
        extra_kwargs = {
            'report_template': {'allow_blank': True},
            'report_styles': {'allow_blank': True},
        }


class ProjectTypePreviewSerializer(serializers.ModelSerializer):
    report_template = serializers.CharField(required=False, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_blank=True)
    report_preview_data = serializers.DictField(required=False)

    class Meta:
        model = ProjectType
        fields = ['report_template', 'report_styles', 'report_preview_data']
        extra_kwargs = {
            'report_template': {'allow_blank': True},
            'report_styles': {'allow_blank': True},
        }


class ProjectTypeCopySerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjectType
        fields = ['name']
        extra_kwargs = {'name': {'required': False}}


class PentestFindingSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='finding_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = serializers.PrimaryKeyRelatedField(source='project.project_type_id', read_only=True)
    lock_info = LockInfoSerializer(read_only=True)
    template = serializers.PrimaryKeyRelatedField(read_only=True)
    assignee = RelatedUserSerializer(required=False, allow_null=True, default=serializers.CreateOnlyDefault(serializers.CurrentUserDefault()))

    class Meta:
        model = PentestFinding
        fields = [
            'id', 'created', 'updated', 'project', 'project_type', 
            'language', 'lock_info', 'template', 'assignee', 'status',
        ]

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=self.context['project'].project_type.finding_fields_obj, **self.get_extra_kwargs().get('data', {})),
        }

    def create(self, validated_data):
        data = ensure_defined_structure(
            value=validated_data.pop('data', {}), 
            definition=self.context['project'].project_type.finding_fields_obj, 
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
        )
        instance = PentestFinding(
            project=self.context['project'], 
            **validated_data
        )
        instance.update_data(data)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class PentestFindingFromTemplateSerializer(PentestFindingSerializer):
    template = serializers.PrimaryKeyRelatedField(queryset=FindingTemplate.objects.all(), required=True, allow_null=False)

    class Meta(PentestFindingSerializer.Meta):
        read_only_fields = ['data']

    @transaction.atomic()
    def create(self, validated_data):
        template = validated_data.get('template')
        finding = super().create(validated_data | {
            'data': template.data | validated_data.pop('data', {}),
        })
        FindingTemplate.objects.filter(id=template.id).increment_usage_count()
        return finding


class PentestProjectSerializer(serializers.ModelSerializer):
    pentesters = RelatedUserSerializer(many=True, required=False, allow_empty=True)
    imported_pentesters = ImportedPentestUserSerializer(many=True, read_only=True)

    details = serializers.HyperlinkedIdentityField(view_name='pentestproject-detail', read_only=True)
    findings = serializers.HyperlinkedIdentityField(view_name='finding-list', lookup_url_kwarg='project_pk', read_only=True)
    sections = serializers.HyperlinkedIdentityField(view_name='section-list', lookup_url_kwarg='project_pk', read_only=True)
    images = serializers.HyperlinkedIdentityField(view_name='uploadedimage-list', lookup_url_kwarg='project_pk', read_only=True)

    class Meta:
        model = PentestProject
        fields = [
            'id', 'created', 'updated',
            'name', 'project_type', 'language', 'readonly', 'source',
            'pentesters', 'imported_pentesters',
            'details', 'findings', 'sections', 'images',
        ]
        read_only_fields = ['readonly']

    def validate_project_type(self, value):
        if not self.instance or self.instance.project_type == value:
            return value
        res_finding = check_definitions_compatible(self.instance.project_type.finding_fields_obj, value.finding_fields_obj, path=('finding_fields',))
        res_report = check_definitions_compatible(self.instance.project_type.report_fields_obj, value.report_fields_obj, path=('report_fields',))
        if not res_finding[0] or not res_report[0]:
            raise serializers.ValidationError(['Designs have incompatible field definitions. Converting might result in data loss.'] + res_report[1] + res_finding[1])
        return value

    @transaction.atomic
    def create(self, validated_data):
        project_type = validated_data.get('project_type')
        pentesters = validated_data.pop('pentesters', [])

        project = super().create(validated_data | {
            'language': project_type.language,
            'custom_fields': ensure_defined_structure(
                value={
                    'title': validated_data.get('name', 'Report Title'),
                }, 
                definition=validated_data['project_type'].report_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
            ),
        })
        project.pentesters.add(self.context['request'].user, *pentesters)
        return project


class ReportSectionSerializer(serializers.ModelSerializer):
    id = serializers.CharField(source='section_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = serializers.PrimaryKeyRelatedField(source='project.project_type_id', read_only=True)
    label = serializers.CharField(source='section_label', read_only=True)
    fields = serializers.ListField(source='section_fields', child=serializers.CharField(), read_only=True)
    lock_info = LockInfoSerializer()
    assignee = RelatedUserSerializer(required=False, allow_null=True)

    class Meta:
        model = ReportSection
        fields = [
            'id', 'label', 'fields', 'project', 'project_type', 
            'language', 'lock_info', 'assignee', 'status',
        ]
    
    def get_fields(self):
        fields = super().get_fields()
        data_field = serializers.DictField()
        if self.instance and isinstance(self.instance, ReportSection):
            data_field = serializer_from_definition(definition=self.instance.field_definition, **self.get_extra_kwargs().get('data', {}))
        return fields | {
            'data': data_field
        }

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        instance.project.save()
        return super().update(instance, validated_data)


class FindingTemplateSerializer(serializers.ModelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='findingtemplate-detail', read_only=True)
    lock_info = LockInfoSerializer()

    class Meta:
        model = FindingTemplate
        fields = [
            'id', 'created', 'updated', 'details', 
            'lock_info', 'usage_count', 'source',
            'tags', 'language', 'status', 
        ]
        read_only_fields = ['usage_count']
        extra_kwargs = {
            'tags': {'required': False, 'allow_empty': True}
        }

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=FindingTemplate.field_definition),
        }

    def create(self, validated_data):
        data = validated_data.pop('data', {})
        instance = FindingTemplate(**validated_data)
        instance.update_data(data)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class UploadedFileSerilaizer(serializers.ModelSerializer):
    compress_images = True

    class Meta:
        fields = ['id', 'created', 'updated', 'name', 'file']
        extra_kwargs = {
            'file': {'write_only': True}, 
            'name': {'required': False},
        }

    def get_linked_object(self):
        return None

    def create(self, validated_data):
        if self.compress_images:
            validated_data['file'], validated_data['name'] = compress_image(validated_data['file'], validated_data.get('name'))
        validated_data['linked_object'] = self.get_linked_object()
        validated_data['uploaded_by'] = self.context['request'].user
        return super().create(validated_data)


class UploadedImageSerializer(UploadedFileSerilaizer):
    class Meta(UploadedFileSerilaizer.Meta):
        model = UploadedImage

    def get_linked_object(self):
        return self.context['project']


class UploadedAssetSerializer(UploadedFileSerilaizer):
    class Meta(UploadedFileSerilaizer.Meta):
        model = UploadedAsset
    
    def get_linked_object(self):
        return self.context['project_type']


class PreviewPdfOptionsSerializer(serializers.Serializer):
    project_type = serializers.PrimaryKeyRelatedField(queryset=ProjectType.objects.all(), required=False, allow_null=True)


class PublishPdfOptionsSerializer(PreviewPdfOptionsSerializer):
    password = serializers.CharField(required=False, allow_null=True, allow_blank=True)


class ImportSerializer(serializers.Serializer):
    file = serializers.FileField()


class PentestProjectReadonlySerializer(serializers.ModelSerializer):
    class Meta:
        model = PentestProject
        fields = ['readonly']
