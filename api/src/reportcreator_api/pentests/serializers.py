from email.policy import default
from rest_framework import serializers
from django.db import transaction
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_CORE, REPORT_FIELDS_CORE
from reportcreator_api.pentests.customfields.serializers import serializer_from_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure
from reportcreator_api.pentests.models import FindingTemplate, LockInfo, PentestFinding, PentestProject, PentestReport, ProjectType, ReportSection, UploadedAsset, UploadedImage
from reportcreator_api.users.serializers import PentestUserSerializer, RelatedUserSerializer
from reportcreator_api.utils.utils import omit_keys


class LockInfoSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    def __init__(self, *args, **kwargs):
        kwargs['read_only'] = True
        super().__init__(*args, **kwargs)
    
    class Meta:
        model = LockInfo
        fields = [
            'created', 'updated', 'last_ping', 'expires', 'user',
        ]
        read_only_fields = ['last_ping']



class ProjectTypeShortSerializer(serializers.ModelSerializer):
    assets = serializers.HyperlinkedIdentityField(view_name='uploadedasset-list', lookup_url_kwarg='projecttype_pk', read_only=True)

    class Meta:
        model = ProjectType
        fields = [
            'id', 'created', 'updated', 
            'name', 'language',
            'assets',
        ]


class ProjectTypeDetailSerializer(ProjectTypeShortSerializer):
    lock_info = LockInfoSerializer()

    class Meta(ProjectTypeShortSerializer.Meta):
        fields = ProjectTypeShortSerializer.Meta.fields + [
            'lock_info',
            'report_template', 'report_styles', 'report_preview_data',
            'report_fields', 'report_sections',
            'finding_fields', 'finding_field_order',
        ]
        extra_kwargs = {
            'report_template': {'allow_blank': True},
            'report_styles': {'allow_blank': True},
        }


class ProjectTypePreviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjectType
        fields = ['report_template', 'report_styles', 'report_preview_data']
        extra_kwargs = {
            'report_template': {'allow_blank': True},
            'report_styles': {'allow_blank': True},
        }


class PentestFindingSerializer(serializers.ModelSerializer):
    project = serializers.PrimaryKeyRelatedField(source='report.project', read_only=True)
    project_type = serializers.PrimaryKeyRelatedField(source='report.project.project_type_id', read_only=True)
    lock_info = LockInfoSerializer(read_only=True)
    assignee = RelatedUserSerializer(required=False, allow_null=True, default=serializers.CreateOnlyDefault(serializers.CurrentUserDefault()))

    class Meta:
        model = PentestFinding
        fields = [
            'id', 'created', 'updated', 'project', 'project_type', 
            'language', 'lock_info', 'assignee',
        ]

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=self.context['project'].project_type.finding_fields_obj, source='fields', **self.get_extra_kwargs().get('data', {})),
        }

    def create(self, validated_data):
        fields = ensure_defined_structure(
            value=validated_data.pop('fields', {}), 
            definition=self.context['project'].project_type.finding_fields_obj, 
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
        )
        instance = PentestFinding(
            report=self.context['project'].report, 
            **validated_data
        )
        instance.update_fields(fields)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_fields(validated_data.pop('fields', {}))
        return super().update(instance, validated_data)


class PentestFindingFromTemplateSerializer(PentestFindingSerializer):
    template = serializers.PrimaryKeyRelatedField(queryset=FindingTemplate.objects.all(), write_only=True)

    class Meta(PentestFindingSerializer.Meta):
        fields = PentestFindingSerializer.Meta.fields + ['template']
        read_only_fields = ['data']

    @transaction.atomic()
    def create(self, validated_data):
        template = validated_data.pop('template')
        finding = super().create(validated_data | {
            'fields': template.fields | validated_data.pop('fields', {}),
        })
        FindingTemplate.objects.filter(id=template.id).increment_usage_count()
        return finding


class PentestProjectSerializer(serializers.ModelSerializer):
    pentesters = RelatedUserSerializer(many=True, required=False, allow_empty=True)

    findings = serializers.HyperlinkedIdentityField(view_name='finding-list', lookup_url_kwarg='project_pk', read_only=True)
    sections = serializers.HyperlinkedIdentityField(view_name='section-list', lookup_url_kwarg='project_pk', read_only=True)
    images = serializers.HyperlinkedIdentityField(view_name='uploadedimage-list', lookup_url_kwarg='project_pk', read_only=True)

    class Meta:
        model = PentestProject
        fields = [
            'id', 'created', 'updated',
            'name', 'project_type', 'language', 'pentesters',
            'findings', 'sections', 'images',
        ]


    @transaction.atomic
    def create(self, validated_data):
        project_type = validated_data.get('project_type')
        pentesters = validated_data.pop('pentesters', [])

        project = super().create(validated_data | {
            'language': project_type.language,
            'report': PentestReport.objects.create(
                title=validated_data.get('name', 'Report Title'), 
                custom_fields=ensure_defined_structure(
                    value={}, 
                    definition=omit_keys(validated_data['project_type'].report_fields_obj, REPORT_FIELDS_CORE), 
                    handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
                ),
            )
        })
        project.pentesters.add(self.context['request'].user, *pentesters)
        return project


class ReportSectionSerializer(serializers.ModelSerializer):
    id = serializers.CharField(source='section_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(source='report.project', read_only=True)
    project_type = serializers.PrimaryKeyRelatedField(source='report.project.project_type_id', read_only=True)
    label = serializers.CharField(source='section_label', read_only=True)
    fields = serializers.ListField(source='section_fields', child=serializers.CharField(), read_only=True)
    lock_info = LockInfoSerializer()
    assignee = RelatedUserSerializer(required=False, allow_null=True)

    class Meta:
        model = ReportSection
        fields = [
            'id', 'label', 'fields', 'project', 'project_type', 
            'language', 'lock_info', 'assignee',
            ]
    
    def get_fields(self):
        fields = super().get_fields()
        data_field = serializers.DictField(source='fields')
        if self.instance and isinstance(self.instance, ReportSection):
            data_field = serializer_from_definition(definition=self.instance.field_definition, source='fields', **self.get_extra_kwargs().get('data', {}))
        return fields | {
            'data': data_field
        }

    def update(self, instance, validated_data):
        instance.update_fields(validated_data.pop('fields', {}))
        instance.report.save()
        return super().update(instance, validated_data)


class FindingTemplateSerializer(serializers.ModelSerializer):
    lock_info = LockInfoSerializer()

    class Meta:
        model = FindingTemplate
        fields = [
            'id', 'created', 'updated', 'lock_info',
            'usage_count', 'tags', 'language',
        ]
        read_only_fields = ['usage_count']
        extra_kwargs = {
            'tags': {'required': False, 'allow_empty': True}
        }

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=FindingTemplate.field_definition, source='fields'),
        }

    def create(self, validated_data):
        fields = validated_data.pop('fields', {})
        instance = FindingTemplate(**validated_data)
        instance.update_fields(fields)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_fields(validated_data.pop('fields', {}))
        return super().update(instance, validated_data)



class UploadedImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = UploadedImage
        fields = ['id', 'created', 'updated', 'name', 'file']
        extra_kwargs = {
            'file': {'write_only': True}, 
            'name': {'required': False},
        }
    
    def create(self, validated_data):
        validated_data['linked_object'] = self.context['project']
        validated_data['uploaded_by'] = self.context['request'].user
        return super().create(validated_data)


class UploadedAssetSerializer(serializers.ModelSerializer):
    class Meta:
        model = UploadedAsset
        fields = ['id', 'created', 'updated', 'name', 'file']
        extra_kwargs = {
            'file': {'write_only': True}, 
            'name': {'required': False},
        }
    
    def create(self, validated_data):
        validated_data['linked_object'] = self.context['project_type']
        validated_data['uploaded_by'] = self.context['request'].user
        return super().create(validated_data)


class PublishPdfOptionsSerializer(serializers.Serializer):
    password = serializers.CharField(required=False, allow_null=True, allow_blank=True)

