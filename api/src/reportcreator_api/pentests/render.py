import dataclasses
import html
from io import BytesIO
import json
import logging
from types import NoneType
import uuid
import pyppeteer
import pikepdf
from typing import Any, Optional, Union
from django.conf import settings
from django.urls import reverse
from django.core.serializers.json import DjangoJSONEncoder
from asgiref.sync import async_to_sync
from contextlib import asynccontextmanager
from weasyprint import HTML, CSS, default_url_fetcher
from weasyprint.text.fonts import FontConfiguration
from weasyprint.urls import URLFetchingError
from reportcreator_api.pentests import cvss
from reportcreator_api.pentests.customfields.types import FieldDataType, FieldDefinition, EnumChoice
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.error_messages import ErrorMessage, MessageLevel, MessageLocationInfo, MessageLocationType

from reportcreator_api.pentests.models import PentestProject, ProjectType
from reportcreator_api.utils.error_messages import ErrorMessage
from reportcreator_api.utils.utils import get_key_or_attr
from reportcreator_api.utils.logging import log_timing


log = logging.getLogger(__name__)


class PdfRenderingError(Exception):
    def __init__(self, messages) -> None:
        super().__init__(messages)
        self.messages = messages


@asynccontextmanager
async def get_page():
    browser = await pyppeteer.launch(
        executablePath=settings.PYPPETEER_EXECUTABLE,
        args=['--no-sandbox', '--single-process'],
        headless=True,
        handleSIGINT=False,
        handleSIGTERM=False,
        handleSIGHUP=False
    )
    try:
        page = await browser.newPage()
        # block all external requests
        await page.setOfflineMode(True)

        yield page
    finally:
        await browser.close()


# @cache
def get_render_script():
    return (settings.PDF_RENDER_SCRIPT_PATH).read_text()


async def render_to_html(report_template: str, data: dict, language: str):
    async with get_page() as page:
        console_output = []
        page.on('console', lambda l: console_output.append(l))
        await page.setContent(f"""
            <!DOCTYPE html>
            <html lang="{html.escape(language)}">
            <head>
                <meta charset="utf-8">
                <title>{html.escape(data.get('title', ''))}</title>
            </head>
            <body>
            </body>
        """)

        # set global window variables
        await page.evaluate(f"""() => {{
            window.REPORT_TEMPLATE = {json.dumps(report_template, cls=DjangoJSONEncoder)};
            window.REPORT_DATA = {json.dumps(data, cls=DjangoJSONEncoder)};
        }}""")
        
        await page.addScriptTag(content=get_render_script())

        # Wait for template to finish rendering
        await page.waitForFunction("""window.RENDERING_COMPLETED === true""");

        if console_output:
            log.info(f'Chromium console output: {[(l.type, l.text) for l in console_output]}')
        
        render_errors = [l for l in console_output if l.type == 'error']
        if not render_errors:
            # Remove script tag from HTML output
            await page.evaluate("""() => document.head.querySelectorAll('script').forEach(s => s.remove())""")
            # Get rendered HTML
            return await page.content()
        else:
            # Report render errors
            errors = []
            for e in render_errors:
                msg = ErrorMessage(level=MessageLevel.ERROR, location=MessageLocationInfo(type=MessageLocationType.DESIGN), message=e.text)
                if len(e.args) == 2 and (error_data := await e.args[1].jsonValue()) and 'message' in error_data:
                    msg.message = error_data.get('message')
                    msg.details = error_data.get('details')
                errors.append(msg)
            raise PdfRenderingError(errors)


@log_timing
def render_to_html_sync(*args, **kwargs):
    return async_to_sync(render_to_html)(*args, **kwargs)


def weasyprint_strip_pdf_metadata(doc, pdf):
    # remove Producer meta-data info from PDF
    del pdf.info['Producer']


@log_timing
def render_to_pdf(html_content: str, report_styles: str, project_type: ProjectType, project: Optional[PentestProject] = None) -> bytes:
    errors = []
    available_assets = project_type.assets.all()
    available_images = project.images.all() if project else []

    def get_resource(url: str, prefixes: list[str], resources: list):
        selector = None
        for prefix in prefixes:
            if url.startswith(prefix + 'name/'):
                name = url[len(prefix) + len('name/'):].split('/')[0]
                selector = ('name', name)
            if url.startswith(prefix):
                id = url[len(prefix):].split('/')[0]
                try:
                    id = uuid.UUID(url[len(prefix):].split('/')[0])
                    selector = ('id', id)
                except ValueError:
                    pass
        
        if not selector:
            return None
        
        res = list(filter(lambda r: getattr(r, selector[0], None) == selector[1], resources))
        if len(res) > 0:
            return res[0]
        else:
            errors.append(ErrorMessage(
                level=MessageLevel.ERROR, 
                location=MessageLocationInfo(type=MessageLocationType.DESIGN), 
                message='Resource not found',
                details=f'Could not find resource for URL "{url}". Check if the URL is correct and the resource exists on the server.'
            ))
            raise URLFetchingError("Resource not found")

    def weasyprint_url_fetcher(url, timeout=10, ssl_context=None):
        # allow data URLs
        if url.startswith('data:'):
            return default_url_fetcher(url=url, timeout=timeout, ssl_context=ssl_context)
        # allow local image and asset loading (previously uploaded)
        elif asset := get_resource(url, prefixes=[
                '/assets/', 
                reverse('uploadedasset-list', kwargs={'projecttype_pk': project_type.id})
            ], resources=available_assets):
            return {
                'file_obj': asset.file.open(),
                'filename': asset.name,
            }
        elif project and (image := get_resource(url, prefixes=[
                '/images/', 
                reverse('uploadedimage-list', kwargs={'project_pk': project.id }), 
            ], resources=available_images)):
            return {
                'file_obj': image.file.open(),
                'filename': image.name,
            }
        else:
            # block all external requests
            errors.append(ErrorMessage(
                level=MessageLevel.ERROR, 
                location=MessageLocationInfo(type=MessageLocationType.DESIGN),
                message=f'Blocked external request to "{url}"',
                details='Requests to external systems are forbidden for security reasons.\nUpload this resource as assset and include it via its asset URL.'
            ))
            raise URLFetchingError('External requests not allowed')

    font_config = FontConfiguration()
    html = HTML(string=html_content, base_url='reportcreator://', url_fetcher=weasyprint_url_fetcher)
    css = CSS(string=report_styles, font_config=font_config, base_url='reportcreator://', url_fetcher=weasyprint_url_fetcher)
    res = html.render(stylesheets=[css], font_config=font_config, optimize_size=[])

    if errors:
        raise PdfRenderingError(errors)

    return res.write_pdf(finisher=weasyprint_strip_pdf_metadata)


def format_template_field_object(value: dict, definition: dict[str, FieldDefinition], imported_pentesters: Optional[list[dict]] = None, require_id=False):
    out = value | ensure_defined_structure(value=value, definition=definition)
    for k, d in (definition or {}).items():
        out[k] = format_template_field(value=out.get(k), definition=d, imported_pentesters=imported_pentesters)

    if require_id and 'id' not in out:
        out['id'] = str(uuid.uuid4())
    return out


def format_template_field_user(value: Union[PentestUser, str, uuid.UUID, None], imported_pentesters: Optional[list[dict]] = None):
    def format_user(u: Union[PentestUser, dict, None]):
        if not u:
            return None
        out = {}
        for k in ['id', 'name', 'title_before', 'first_name', 'middle_name', 'last_name', 'title_after', 'email', 'phone', 'mobile']:
            out[k] = get_key_or_attr(u, k, '')
        return out

    if isinstance(value, (PentestUser, NoneType)):
        return format_user(value)
    elif u := next(filter(lambda i: str(i.get('id')) == str(value), imported_pentesters or []), None):
        return format_user(u)
    else:
        return format_user(PentestUser.objects.filter(id=value).first())


def format_template_field(value: Any, definition: FieldDefinition, imported_pentesters: Optional[list[dict]] = None):
    value_type = definition.type
    if value_type == FieldDataType.ENUM:
        return dataclasses.asdict(next(filter(lambda c: c.value == value, definition.choices), EnumChoice(value='', label='')))
    elif value_type == FieldDataType.CVSS:
        score = cvss.calculate_score(value)
        return {
            'vector': value,
            'score': str(round(score, 2)),
            'level': cvss.level_from_score(score).value,
            'level_number': cvss.level_number_from_score(score)
        }
    elif value_type == FieldDataType.USER:
        return format_template_field_user(value, imported_pentesters=imported_pentesters)
    elif value_type == FieldDataType.LIST:
        return [format_template_field(value=e, definition=definition.items, imported_pentesters=imported_pentesters) for e in value]
    elif value_type == FieldDataType.OBJECT:
        return format_template_field_object(value=value, definition=definition.properties, imported_pentesters=imported_pentesters)
    else:
        return value


def format_template_data(data: dict, project_type: ProjectType, imported_pentesters: Optional[list[dict]] = None):
    data['report'] = format_template_field_object(
        value=ensure_defined_structure(
            value=data.get('report', {}), 
            definition=project_type.report_fields_obj,
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT),
        definition=project_type.report_fields_obj, 
        imported_pentesters=imported_pentesters,
        require_id=True)
    data['findings'] = [
        format_template_field_object(
            value=(f if isinstance(f, dict) else {}) | ensure_defined_structure(
                value=f, 
                definition=project_type.finding_fields_obj,
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT),
            definition=project_type.finding_fields_obj, 
            imported_pentesters=imported_pentesters,
            require_id=True) 
        for f in data.get('findings', [])]
    data['pentesters'] = data.get('pentesters', []) + (imported_pentesters or [])
    return data


def render_pdf(project_type: ProjectType, project: PentestProject) -> bytes:
    data = {
        'report': {
            'id': str(project.id),
            **project.data,
        },
        'findings': [{
            'id': str(f.finding_id),
            **f.data,
        } for f in project.findings.all()],
        'pentesters': [format_template_field_user(u) for u in project.pentesters.all()],
    }
    data = format_template_data(data=data, project_type=project_type, imported_pentesters=project.imported_pentesters)
    html = render_to_html_sync(report_template=project_type.report_template, data=data, language=project.language)
    return render_to_pdf(html_content=html, report_styles=project_type.report_styles, project_type=project_type, project=project)


def render_pdf_preview(project_type: ProjectType, report_template: str, report_styles: str, report_preview_data: dict) -> bytes:
    preview_data = report_preview_data.copy()
    preview_data['findings'] = sorted(preview_data.get('findings', []), key=lambda f: (-cvss.calculate_score(f.get('cvss')), f.get('id')))
    data = format_template_data(data=preview_data, project_type=project_type)
    
    html = render_to_html_sync(report_template=report_template, data=data, language=project_type.language)
    return render_to_pdf(html_content=html, report_styles=report_styles, project_type=project_type)


@log_timing
def post_process_pdf(pdf_data: bytes, password: Optional[str]) -> bytes:
    if not password:
        return pdf_data

    with pikepdf.Pdf.open(BytesIO(pdf_data)) as pdf:
        out = BytesIO()
        # Encrypt PDF with AES-256
        pdf.save(
            filename_or_stream=out, 
            encryption=pikepdf.Encryption(owner=password, user=password, aes=True, R=6) if password else False,
            compress_streams=True
        )
        return out.getvalue()

