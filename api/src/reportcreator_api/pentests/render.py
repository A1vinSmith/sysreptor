import dataclasses
import html
from io import BytesIO
import json
import uuid
import pyppeteer
import pikepdf
from typing import Any, Optional, Union
from django.conf import settings
from django.urls import reverse
from asgiref.sync import async_to_sync
from contextlib import asynccontextmanager
from functools import cache
from weasyprint import HTML, CSS, default_url_fetcher
from weasyprint.text.fonts import FontConfiguration
from weasyprint.urls import URLFetchingError
from reportcreator_api.pentests import cvss
from reportcreator_api.pentests.customfields.types import FieldDataType, FieldDefinition, EnumChoice
from reportcreator_api.pentests.customfields.utils import ensure_defined_structure
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.error_messages import ErrorMessage, MessageLevel, MessageLocationInfo, MessageLocationType

from reportcreator_api.pentests.models import PentestProject, ProjectType, UploadedAsset, UploadedImage
from reportcreator_api.utils.error_messages import ErrorMessage


class PdfRenderingError(Exception):
    def __init__(self, messages) -> None:
        super().__init__(messages)
        self.messages = messages


@asynccontextmanager
async def get_page():
    browser = await pyppeteer.launch(
        executablePath=settings.PYPPETEER_EXECUTABLE,
        args=['--no-sandbox', '--single-process'],
        headless=True,
        handleSIGINT=False,
        handleSIGTERM=False,
        handleSIGHUP=False
    )
    try:
        page = await browser.newPage()
        # block all external requests
        await page.setOfflineMode(True)

        yield page
    finally:
        await browser.close()


# @cache
def get_render_script():
    return (settings.PDF_RENDER_SCRIPT_PATH).read_text()


async def render_to_html(report_template: str, data: dict):
    async with get_page() as page:
        render_errors = []
        page.on('console', lambda l: render_errors.append(l) if l.type == 'error' else ())
        await page.setContent(f"""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="utf-8">
                <title>{html.escape(data.get('title', ''))}</title>
            </head>
            <body>
            </body>
        """)

        # set global window variables
        await page.evaluate(f"""() => {{
            window.REPORT_TEMPLATE = {json.dumps(report_template)};
            window.REPORT_DATA = {json.dumps(data)};
        }}""")
        
        await page.addScriptTag(content=get_render_script())

        # Wait for template to finish rendering
        await page.waitForFunction("""window.RENDERING_COMPLETED === true""");

        if not render_errors:
            # Remove script tag from HTML output
            await page.evaluate("""() => document.head.querySelectorAll('script').forEach(s => s.remove())""")
            # Get rendered HTML
            return await page.content()
        else:
            # Report render errors
            errors = []
            for e in render_errors:
                msg = ErrorMessage(level=MessageLevel.ERROR, location=MessageLocationInfo(type=MessageLocationType.TEMPLATE), message=e.text)
                if len(e.args) == 2 and (error_data := await e.args[1].jsonValue()) and 'message' in error_data:
                    msg.message = error_data.get('message')
                    msg.details = error_data.get('details')
                errors.append(msg)
            raise PdfRenderingError(errors)


def weasyprint_strip_pdf_metadata(doc, pdf):
    # remove Producer meta-data info from PDF
    del pdf.info['Producer']


def render_to_pdf(html_content: str, report_styles: str, project_type: ProjectType, project: Optional[PentestProject] = None) -> bytes:
    errors = []
    available_assets = UploadedAsset.objects.filter(linked_object=project_type)
    available_images = UploadedImage.objects.filter(linked_object=project) if project else []

    def get_resource(url: str, prefixes: list[str], resources: list, id_field='id'):
        selector = None
        for prefix in prefixes:
            if url.startswith(prefix + 'name/'):
                name = url[len(prefix) + len('name/'):].split('/')[0]
                selector = ('name', name)
            if url.startswith(prefix):
                id = url[len(prefix):].split('/')[0]
                try:
                    id = uuid.UUID(url[len(prefix):].split('/')[0])
                    selector = ('id', id)
                except ValueError:
                    pass
        
        if not selector:
            return None
        
        res = list(filter(lambda r: getattr(r, selector[0], None) == selector[1], resources))
        if len(res) > 0:
            return res[0]
        else:
            errors.append(ErrorMessage(
                level=MessageLevel.ERROR, 
                location=MessageLocationInfo(type=MessageLocationType.TEMPLATE), 
                message='Resource not found',
                details=f'Could not find resource for URL "{url}". Check if the URL is correct and the resource exists on the server.'
            ))
            raise URLFetchingError("Resource not found")

    def weasyprint_url_fetcher(url, timeout=10, ssl_context=None):
        print('Weasyprint URL', url)
        # allow data URLs
        if url.startswith('data:'):
            return default_url_fetcher(url=url, timeout=timeout, ssl_context=ssl_context)
        # allow local image and asset loading (previously uploaded)
        elif asset := get_resource(url, prefixes=[
                '/assets/', 
                reverse('uploadedasset-list', kwargs={'projecttype_pk': project_type.id})
            ], resources=available_assets):
            return {
                'file_obj': asset.file.open(),
                'filename': asset.name,
            }
        elif project and (image := get_resource(url, prefixes=[
                '/images/', 
                reverse('uploadedimage-list', kwargs={'project_pk': project.id }), 
            ], resources=available_images)):
            return {
                'file_obj': image.file.open(),
                'filename': image.name,
            }
        else:
            # block all external requests
            errors.append(ErrorMessage(
                level=MessageLevel.ERROR, 
                location=MessageLocationInfo(type=MessageLocationType.TEMPLATE),
                message=f'Blocked external request to "{url}"',
                details='Requests to external systems are forbidden for security reasons.\nUpload this resource as assset and include it via its asset URL.'
            ))
            raise URLFetchingError('External requests not allowed')

    font_config = FontConfiguration()
    html = HTML(string=html_content, base_url='reportcreator://', url_fetcher=weasyprint_url_fetcher)
    css = CSS(string=report_styles, font_config=font_config, base_url='reportcreator://', url_fetcher=weasyprint_url_fetcher)
    res = html.render(stylesheets=[css], font_config=font_config, optimize_size=[])

    if errors:
        raise PdfRenderingError(errors)

    return res.write_pdf(finisher=weasyprint_strip_pdf_metadata)


def format_template_field_object(value: dict, definition: dict[str, FieldDefinition], require_id=False):
    out = value | ensure_defined_structure(value=value, definition=definition)
    for k, d in (definition or {}).items():
        out[k] = format_template_field(value=out.get(k), definition=d)

    if require_id and 'id' not in out:
        out['id'] = str(uuid.uuid4())
    return out

def format_template_field_user(u: Union[PentestUser, str, None]):
    if isinstance(u, str):
        u = PentestUser.objects.filter(id=u).first()
    if not u:
        return None
    return {
        'id': str(u.id),
        'username': u.username,
        'email': u.email,
        'phone': u.phone,
        'mobile': u.mobile,
        'name': u.name,
        'title_before': u.title_before,
        'first_name': u.first_name,
        'middle_name': u.middle_name,
        'last_name': u.last_name,
        'title_after': u.title_after,
    }


def format_template_field(value: Any, definition: FieldDefinition):
    value_type = definition.type
    if value_type == FieldDataType.ENUM:
        return dataclasses.asdict(next(filter(lambda c: c.value == value, definition.choices), EnumChoice(value='', label='')))
    elif value_type == FieldDataType.CVSS:
        score = cvss.calculate_score(value)
        return {
            'vector': value,
            'score': str(round(score, 2)),
            'level': cvss.level_from_score(score).value,
            'level_number': cvss.level_number_from_score(score)
        }
    elif value_type == FieldDataType.USER:
        return format_template_field_user(value)
    elif value_type == FieldDataType.LIST:
        return [format_template_field(value=e, definition=definition.items) for e in value]
    elif value_type == FieldDataType.OBJECT:
        return format_template_field_object(value=value, definition=definition.properties)
    else:
        return value


def format_template_data(data: dict, project_type: ProjectType):
    data['report'] = format_template_field_object(data.get('report', {}), project_type.report_fields_obj, require_id=True)
    data['findings'] = [format_template_field_object(f, project_type.finding_fields_obj, require_id=True) for f in data.get('findings', [])]
    data['pentesters'] = data.get('pentesters', [])
    return data


def render_pdf(project_type: ProjectType, project: PentestProject) -> bytes:
    data = {
        'report': {
            'id': str(project.report.id),
            **project.report.fields,
        },
        'findings': [{
            'id': str(f.id),
            **f.fields,
        } for f in project.report.pentestfinding_set.order_by('-risk_score')],
        'pentesters': [format_template_field_user(u) for u in project.pentesters.all()],
    }
    data = format_template_data(data=data, project_type=project_type)
    html = async_to_sync(render_to_html)(report_template=project_type.report_template, data=data)
    return render_to_pdf(html_content=html, report_styles=project_type.report_styles, project_type=project_type, project=project)


def render_pdf_preview(project_type: ProjectType, report_template: str, report_styles: str, report_preview_data: dict) -> bytes:
    data = format_template_data(data=report_preview_data.copy(), project_type=project_type)
    html = async_to_sync(render_to_html)(report_template=report_template, data=data)
    return render_to_pdf(html_content=html, report_styles=report_styles, project_type=project_type)


def post_process_pdf(pdf_data: bytes, password: Optional[str]) -> bytes:
    with pikepdf.Pdf.open(BytesIO(pdf_data)) as pdf:
        out = BytesIO()
        # Encrypt PDF with AES-256
        pdf.save(
            filename_or_stream=out, 
            encryption=pikepdf.Encryption(owner=password, user=password, aes=True, R=6) if password else False,
            compress_streams=True
        )
        return out.getvalue()
