import functools
import operator
import random
import copy
from django.db import models, transaction
from django.core.files.base import ContentFile

from reportcreator_api.pentests.customfields.types import FieldOrigin, parse_field_definition
from reportcreator_api.utils.files import normalize_filename
from reportcreator_api.utils.utils import omit_keys


class ProjectTypeQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(models.Q(linked_project=None) | models.Q(linked_project__members__user=user))

    def custom_finding_field_definitions(self):
        """
        Return all custom field definitions over all globally visible ProjectTypes.
        Handle conflicting data types of custom fields by using the field of the first ProjectType
        e.g. ProjectType1 defines custom_field: string; ProjectType2 defines custom_field: list[string] => use custom_field: string
        """
        all_finding_field_definitions = self \
            .filter(linked_project=None) \
            .order_by('-created', 'id') \
            .values_list('finding_fields', flat=True)
        return parse_field_definition(functools.reduce(
            operator.or_, 
            map(lambda fd: dict(filter(lambda t: t[1].get('origin') == FieldOrigin.CUSTOM.value, fd.items())), all_finding_field_definitions),
            {}
        ))


class ProjectTypeManager(models.Manager.from_queryset(ProjectTypeQueryset)):
    @transaction.atomic()
    def copy(self, instance, data=None):
        from reportcreator_api.pentests.models import UploadedAsset, SourceEnum

        assets = list(instance.assets.all())

        # Copy model
        instance = copy.copy(instance)
        for k, v in ({'name': 'Copy of ' + instance.name, 'source': SourceEnum.CREATED} | (data or {})).items():
            setattr(instance, k, v)
        instance.pk = None
        instance.lock_info_data = None
        instance.save()

        # Copy all assets
        for a in assets:
            a.pk = None
            a.linked_object = instance
        UploadedAsset.objects.bulk_create(assets)

        return instance


class PentestProjectQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(members__user=user)


class PentestProjectManager(models.Manager.from_queryset(PentestProjectQueryset)):
    @transaction.atomic()
    def copy(self, instance, data=None):
        from reportcreator_api.pentests.models import PentestFinding, ReportSection, UploadedImage, SourceEnum, ProjectMemberInfo

        findings = list(instance.findings.all())
        sections = list(instance.sections.all())
        members = list(instance.members.all())
        images = list(instance.images.all())

        # Copy project
        instance = copy.copy(instance)
        for k, v in ({'name': 'Copy of ' + instance.name, 'source': SourceEnum.CREATED} | (data or {})).items():
            setattr(instance, k, v)
        instance.pk = None
        instance.readonly = False
        instance.lock_info_data = None
        instance.save()

        for mi in members:
            mi.pk = None
            mi.project = instance
        ProjectMemberInfo.objects.bulk_create(members)

        # Copy sections
        ReportSection.objects.filter(project=instance).delete()
        for s in sections:
            s.pk = None
            s.project = instance
        ReportSection.objects.bulk_create(sections)

        # Copy findings
        for f in findings:
            f.pk = None
            f.project = instance
        PentestFinding.objects.bulk_create(findings)

        # Copy images
        for i in images:
            i.pk = None
            i.linked_object = instance
        UploadedImage.objects.bulk_create(images)

        return instance
    
    @transaction.atomic
    def set_members(self, instance, members):
        from reportcreator_api.pentests.models import ProjectMemberInfo

        if members is None:
            return

        for m in members:
            m.pk = None
            m.project = instance
            m.roles = list(set(m.roles))
        
        members_map = dict(map(lambda m: (m.user_id, m), members))
        existing_members_map = dict(map(lambda m: (m.user_id, m), instance.members.all()))

        if new_members := omit_keys(members_map, existing_members_map.keys()).values():
            ProjectMemberInfo.objects.bulk_create(new_members)
        if removed_members := omit_keys(existing_members_map, members_map.keys()).values():
            ProjectMemberInfo.objects.filter(id__in=[m.pk for m in removed_members]).delete()

        updated_members = []
        for k, m in existing_members_map.items():
            if k in members_map and set(m.roles) != set(members_map[k].roles):
                m.roles = members_map[k].roles
                updated_members.append(m)
        if updated_members:
            ProjectMemberInfo.objects.bulk_update(updated_members, ['roles'])

    def add_member(self, user, projects):
        from reportcreator_api.pentests.models import ProjectMemberInfo

        existing_members = set(ProjectMemberInfo.objects \
            .filter(project__in=projects) \
            .filter(user=user) \
            .values_list('project_id', flat=True))
        new_members = [ProjectMemberInfo(user=user, project=p) for p in projects if p.id not in existing_members]
        ProjectMemberInfo.objects.bulk_create(new_members)


class PentestFindingQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(project__members__user=user)


class ReportSectionQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(project__members__user=user)


class FindingTemplateQueryset(models.QuerySet):
    def increment_usage_count(self, by=1):
        return self.update(usage_count=models.F('usage_count') + models.Value(by))


class UploadedImageQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(linked_object__members__user=user)


class UploadedAssetQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(models.Q(linked_object__linked_project=None) | models.Q(linked_object__linked_project__members__user=user))


class UploadedFileManagerMixin:
    def create(self, file, linked_object, name=None, **kwargs):
        # Change name when a file with the same name already exists
        name = normalize_filename(name or file.name or 'file')
        while self.filter(linked_object=linked_object).filter(name=name).exists():
            if (ext_idx := name.rfind('.')) and ext_idx != -1:
                name = name[:ext_idx] + '-' + str(random.randint(1, 100000)) + name[ext_idx:]

        return super().create(file=file, name=name, linked_object=linked_object, **kwargs)


class UploadedImageManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedImageQueryset)):
    pass


class UploadedAssetManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedAssetQueryset)):
    pass

