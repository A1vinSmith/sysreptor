import functools
import operator
import random
from django.db import models, transaction
from django.core.files.base import ContentFile

from reportcreator_api.pentests.customfields.types import FieldOrigin, parse_field_definition


class ProjectTypeQueryset(models.QuerySet):
    def custom_finding_field_definitions(self):
        """
        Return all custom field definitions over all ProjectTypes.
        Handle conflicting data types of custom fields by using the field of the first ProjectType
        e.g. ProjectType1 defines custom_field: string; ProjectType2 defines custom_field: list[string]
        """
        all_finding_field_definitions = self \
            .order_by('-created', 'id') \
            .values_list('finding_fields', flat=True)
        return parse_field_definition(functools.reduce(
            operator.or_, 
            map(lambda fd: dict(filter(lambda t: t[1].get('origin') == FieldOrigin.CUSTOM.value, fd.items())), all_finding_field_definitions),
            {}
        ))


class ProjectTypeManager(models.Manager.from_queryset(ProjectTypeQueryset)):
    @transaction.atomic()
    def copy(self, instance):
        from reportcreator_api.pentests.models import UploadedAsset

        assets = list(instance.assets.all())

        # Copy model
        instance.pk = None
        instance.name = 'Copy of ' + instance.name
        instance.save()

        # Copy all assets
        for a in assets:
            a.id = None
            a.linked_object = instance
            a.file = ContentFile(a.file.read(), name=a.file.name)
        UploadedAsset.objects.bulk_create(assets)

        return instance


class PentestProjectQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(pentesters=user)


class PentestProjectManager(models.Manager.from_queryset(PentestProjectQueryset)):
    @transaction.atomic()
    def copy(self, instance):
        from reportcreator_api.pentests.models import PentestFinding, ReportSection, UploadedImage

        report = instance.report
        findings = list(report.findings.all())
        sections = list(report.sections.all())
        pentesters = list(instance.pentesters.all())
        images = list(instance.images.all())

        # Copy report
        report.pk = None
        report.save()

        # Copy sections
        for s in sections:
            s.pk = None
            s.report = report
        ReportSection.objects.bulk_create(sections)

        # Copy findings
        for f in findings:
            f.pk = None
            f.report = report
        PentestFinding.objects.bulk_create(findings)
        
        # Copy project
        instance.pk = None
        instance.name = 'Copy of ' + instance.name
        instance.report = report
        instance.save()
        instance.pentesters.add(*pentesters)

        # Copy images
        for i in images:
            i.pk = None
            i.linked_object = instance
            i.file = ContentFile(i.file.read(), name=i.file.name)  
        UploadedImage.objects.bulk_create(images)

        return instance


class PentestFindingQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(report__project__pentesters=user)


class ReportSectionQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(report__project__pentesters=user)


class FindingTemplateQueryset(models.QuerySet):
    def increment_usage_count(self, by=1):
        return self.update(usage_count=models.F('usage_count') + models.Value(by))


class UploadedImageQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(linked_object__pentesters=user)


class UploadedFileManagerMixin:
    def create(self, file, linked_object, name=None, **kwargs):
        # Change name when a file with the same name already exists
        name = name or file.name
        if self.filter(linked_object=linked_object).filter(name=name).exists():
            if (ext_idx := name.rfind('.')) and ext_idx != -1:
                name = name[:ext_idx] + '-' + str(random.randint(1, 100000)) + name[ext_idx:]

        return super().create(file=file, name=name, linked_object=linked_object, **kwargs)


class UploadedImageManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedImageQueryset)):
    pass


class UploadedAssetManager(UploadedFileManagerMixin, models.Manager):
    pass

