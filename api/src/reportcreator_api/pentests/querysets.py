import functools
import operator
import random
import copy
from django.db import models, transaction
from django.core.files.base import ContentFile

from reportcreator_api.pentests.customfields.types import FieldOrigin, parse_field_definition
from reportcreator_api.utils.files import normalize_filename


class ProjectTypeQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(models.Q(linked_project=None) | models.Q(linked_project__pentesters=user))

    def custom_finding_field_definitions(self):
        """
        Return all custom field definitions over all globally visible ProjectTypes.
        Handle conflicting data types of custom fields by using the field of the first ProjectType
        e.g. ProjectType1 defines custom_field: string; ProjectType2 defines custom_field: list[string] => use custom_field: string
        """
        all_finding_field_definitions = self \
            .filter(linked_project=None) \
            .order_by('-created', 'id') \
            .values_list('finding_fields', flat=True)
        return parse_field_definition(functools.reduce(
            operator.or_, 
            map(lambda fd: dict(filter(lambda t: t[1].get('origin') == FieldOrigin.CUSTOM.value, fd.items())), all_finding_field_definitions),
            {}
        ))


class ProjectTypeManager(models.Manager.from_queryset(ProjectTypeQueryset)):
    @transaction.atomic()
    def copy(self, instance, data=None):
        from reportcreator_api.pentests.models import UploadedAsset, SourceEnum

        assets = list(instance.assets.all())

        # Copy model
        instance = copy.copy(instance)
        for k, v in ({'name': 'Copy of ' + instance.name, 'source': SourceEnum.CREATED} | (data or {})).items():
            setattr(instance, k, v)
        instance.pk = None
        instance.lock_info_data = None
        instance.save()

        # Copy all assets
        for a in assets:
            a.pk = None
            a.linked_object = instance
        UploadedAsset.objects.bulk_create(assets)

        return instance


class PentestProjectQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(pentesters=user)


class PentestProjectManager(models.Manager.from_queryset(PentestProjectQueryset)):
    @transaction.atomic()
    def copy(self, instance, data=None):
        from reportcreator_api.pentests.models import PentestFinding, ReportSection, UploadedImage, SourceEnum

        findings = list(instance.findings.all())
        sections = list(instance.sections.all())
        pentesters = list(instance.pentesters.all())
        images = list(instance.images.all())

        # Copy project
        instance = copy.copy(instance)
        for k, v in ({'name': 'Copy of ' + instance.name, 'source': SourceEnum.CREATED} | (data or {})).items():
            setattr(instance, k, v)
        instance.pk = None
        instance.readonly = False
        instance.lock_info_data = None
        instance.save()
        instance.pentesters.add(*pentesters)

        # Copy sections
        ReportSection.objects.filter(project=instance).delete()
        for s in sections:
            s.pk = None
            s.project = instance
        ReportSection.objects.bulk_create(sections)

        # Copy findings
        for f in findings:
            f.pk = None
            f.project = instance
        PentestFinding.objects.bulk_create(findings)

        # Copy images
        for i in images:
            i.pk = None
            i.linked_object = instance
        UploadedImage.objects.bulk_create(images)

        return instance


class PentestFindingQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(project__pentesters=user)


class ReportSectionQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(project__pentesters=user)


class FindingTemplateQueryset(models.QuerySet):
    def increment_usage_count(self, by=1):
        return self.update(usage_count=models.F('usage_count') + models.Value(by))


class UploadedImageQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(linked_object__pentesters=user)


class UploadedAssetQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_superuser:
            return self
        return self.filter(models.Q(linked_object__linked_project=None) | models.Q(linked_object__linked_project__pentesters=user))


class UploadedFileManagerMixin:
    def create(self, file, linked_object, name=None, **kwargs):
        # Change name when a file with the same name already exists
        name = normalize_filename(name or file.name or 'file')
        while self.filter(linked_object=linked_object).filter(name=name).exists():
            if (ext_idx := name.rfind('.')) and ext_idx != -1:
                name = name[:ext_idx] + '-' + str(random.randint(1, 100000)) + name[ext_idx:]

        return super().create(file=file, name=name, linked_object=linked_object, **kwargs)


class UploadedImageManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedImageQueryset)):
    pass


class UploadedAssetManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedAssetQueryset)):
    pass

