import functools
import operator
import random
import copy
import uuid
from django.conf import settings
from django.db import models, transaction
from django.db.models.functions import Coalesce
from django.core.exceptions import ValidationError

from reportcreator_api.pentests.customfields.types import FieldOrigin, parse_field_definition
from reportcreator_api.utils.files import normalize_filename
from reportcreator_api.utils.utils import groupby_to_dict, omit_keys


class ProjectTypeQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        pt_filters = models.Q(models.Q(linked_project=None) & models.Q(linked_user=None)) | \
            models.Q(linked_project__members__user=user)
        if settings.ENABLE_PRIVATE_DESIGNS:
            pt_filters |= models.Q(linked_user=user)
        return self.filter(pt_filters)

    def custom_finding_field_definitions(self):
        """
        Return all custom field definitions over all globally visible ProjectTypes.
        Handle conflicting data types of custom fields by using the field of the first ProjectType
        e.g. ProjectType1 defines custom_field: string; ProjectType2 defines custom_field: list[string] => use custom_field: string
        """
        all_finding_field_definitions = self \
            .filter(linked_project=None) \
            .order_by('-created', 'id') \
            .values_list('finding_fields', flat=True)
        return parse_field_definition(functools.reduce(
            operator.or_, 
            map(lambda fd: dict(filter(lambda t: t[1].get('origin') == FieldOrigin.CUSTOM.value, fd.items())), all_finding_field_definitions),
            {}
        ))


class ProjectTypeManager(models.Manager.from_queryset(ProjectTypeQueryset)):
    use_in_migrations = True

    @transaction.atomic()
    def copy(self, instance, **kwargs):
        from reportcreator_api.pentests.models import UploadedAsset

        assets = list(instance.assets.all())

        # Copy model
        instance = copy.copy(instance)
        for k, v in (kwargs or {}).items():
            setattr(instance, k, v)
        instance.pk = None
        instance.lock_info_data = None
        instance.save()

        # Copy all assets
        for a in assets:
            a.pk = None
            a.linked_object = instance
        UploadedAsset.objects.bulk_create(assets)

        return instance


class PentestProjectQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        return self.filter(members__user=user)


class PentestProjectManager(models.Manager.from_queryset(PentestProjectQueryset)):
    @transaction.atomic()
    def copy(self, instance, **kwargs):
        from reportcreator_api.pentests.models import PentestFinding, ReportSection, NotebookPage, UploadedImage, UploadedProjectFile, SourceEnum, ProjectMemberInfo

        findings = list(instance.findings.all())
        sections = list(instance.sections.all())
        notes = list(instance.notes.select_related('parent').all())
        members = list(instance.members.all())
        images = list(instance.images.all())
        files = list(instance.files.all())

        # Copy project
        instance = copy.copy(instance)
        for k, v in (kwargs or {}).items():
            setattr(instance, k, v)
        instance.pk = None
        instance.readonly = False
        instance.lock_info_data = None
        instance.project_type = instance.project_type.copy(
            linked_user=None,
            source=SourceEnum.SNAPSHOT if instance.project_type.source not in [SourceEnum.IMPORTED_DEPENDENCY, SourceEnum.CUSTOMIZED] else instance.project_type.source)
        instance.save()
        instance.project_type.linked_project = instance
        instance.project_type.save(update_fields=['linked_project'])

        for mi in members:
            mi.pk = None
            mi.project = instance
        ProjectMemberInfo.objects.bulk_create(members)

        # Copy sections
        ReportSection.objects.filter(project=instance).delete()
        for s in sections:
            s.pk = None
            s.project = instance
        ReportSection.objects.bulk_create(sections)

        # Copy findings
        for f in findings:
            f.pk = None
            f.project = instance
        PentestFinding.objects.bulk_create(findings)

        # Copy notes
        for n in notes:
            n.pk = None
            n.project = instance
        NotebookPage.objects.bulk_create(notes)
        # Update parent to copied model
        for n in notes:
            if n.parent:
                n.parent = next(filter(lambda pn: pn.note_id == n.parent.note_id, notes), None)
        NotebookPage.objects.bulk_update(notes, ['parent'])

        # Copy images
        for i in images:
            i.pk = None
            i.linked_object = instance
        UploadedImage.objects.bulk_create(images)

        # Copy files
        for f in files:
            f.pk = None
            f.linked_object = instance
        UploadedProjectFile.objects.bulk_create(files)

        return instance
    
    @transaction.atomic
    def set_members(self, instance, members):
        from reportcreator_api.pentests.models import ProjectMemberInfo

        if members is None:
            return

        for m in members:
            m.pk = None
            m.project = instance
            m.roles = list(set(m.roles))
        
        members_map = dict(map(lambda m: (m.user_id, m), members))
        existing_members_map = dict(map(lambda m: (m.user_id, m), instance.members.all()))

        if new_members := omit_keys(members_map, existing_members_map.keys()).values():
            ProjectMemberInfo.objects.bulk_create(new_members)
        if removed_members := omit_keys(existing_members_map, members_map.keys()).values():
            ProjectMemberInfo.objects.filter(id__in=[m.pk for m in removed_members]).delete()

        updated_members = []
        for k, m in existing_members_map.items():
            if k in members_map and set(m.roles) != set(members_map[k].roles):
                m.roles = members_map[k].roles
                updated_members.append(m)
        if updated_members:
            ProjectMemberInfo.objects.bulk_update(updated_members, ['roles'])

    def add_member(self, user, projects):
        from reportcreator_api.pentests.models import ProjectMemberInfo

        existing_members = set(ProjectMemberInfo.objects \
            .filter(project__in=projects) \
            .filter(user=user) \
            .values_list('project_id', flat=True))
        new_members = [ProjectMemberInfo(user=user, project=p) for p in projects if p.id not in existing_members]
        ProjectMemberInfo.objects.bulk_create(new_members)


class PentestFindingQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        return self.filter(project__members__user=user)


class ReportSectionQueryset(models.QuerySet):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        return self.filter(project__members__user=user)


class FindingTemplateQueryset(models.QuerySet):
    def increment_usage_count(self, by=1):
        return self.update(usage_count=models.F('usage_count') + models.Value(by))


class NotebookPageQuerySet(models.QuerySet):
    pass


class NotebookPageManager(models.Manager.from_queryset(NotebookPageQuerySet)):
    def create(self, project=None, user=None, order=None, parent=None, **kwargs):
        from reportcreator_api.pentests.models import NotebookPage

        if not order and (project or user):
            if project:
                order_qs = NotebookPage.objects.filter(project=project)
            elif user:
                order_qs = NotebookPage.objects.filter(user=user)
            order = Coalesce(
                models.Subquery(
                    order_qs
                    .filter(parent=parent)
                    .values('parent')
                    .annotate(max_order=models.Max('order'))
                    .values_list('max_order')),
                models.Value(0)
            ) + models.Value(1)
        
        obj = super().create(project=project, user=user, parent=parent, order=order, **kwargs)
        obj.refresh_from_db()
        return obj
    
    def check_parent_and_order(self, instances, missing_instances=None):
        # * Update order values: first all notes in data, then missing notes (keep order of missing notes, but move to end)
        # * and validate no circular dependencies: beginning from the tree root, every note must be in the tree. 
        #   If it does not have a path from root to node, there is a circular dependency.
        missing_instances = missing_instances or []
        parent_dict = groupby_to_dict(instances, key=lambda n: n.parent_id or uuid.UUID(int=0))
        in_tree = set()
        def to_tree(parent_id):
            layer = parent_dict.get(parent_id, [])
            layer_sorted = sorted(filter(lambda n: n not in missing_instances, layer), key=lambda n: n.order) + \
                sorted(filter(lambda n: n in missing_instances, layer), key=lambda n: n.order)
            for idx, n in enumerate(layer_sorted):
                n.order = idx + 1
                in_tree.add(n)
                to_tree(n.id)
        to_tree(uuid.UUID(int=0))
        if len(in_tree) != len(instances):
            raise ValidationError('Circular parent relationships detected')


class UploadedFileQueryset(models.QuerySet):
    def filter_name(self, name):
        from reportcreator_api.pentests.models import UploadedFileBase
        return self.filter(name_hash=UploadedFileBase.hash_name(name))


class UploadedImageQueryset(UploadedFileQueryset):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        return self.filter(linked_object__members__user=user)


class UploadedUserNotebookImageQueryset(UploadedFileQueryset):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        return self.filter(linked_object=user)


class UploadedAssetQueryset(UploadedFileQueryset):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        return self.filter(models.Q(linked_object__linked_project=None) | models.Q(linked_object__linked_project__members__user=user))


class UploadedProjectFileQueryset(UploadedFileQueryset):
    def only_permitted(self, user):
        if user.is_admin:
            return self
        return self.filter(linked_object__members__user=user)


class UploadedFileManagerMixin:
    def create(self, file, linked_object, name=None, **kwargs):
        # Change name when a file with the same name already exists
        name = normalize_filename(name or file.name or 'file')
        while self.filter(linked_object=linked_object).filter_name(name).exists():
            if (ext_idx := name.rfind('.')) and ext_idx != -1:
                name = name[:ext_idx] + '-' + str(random.randint(1, 1000000)) + name[ext_idx:]

        # Randomize filename in storage to not leak information
        return super().create(file=file, name=name, linked_object=linked_object, **kwargs)


class UploadedImageManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedImageQueryset)):
    pass


class UploadedAssetManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedAssetQueryset)):
    pass


class UploadedUserNotebookImageManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedUserNotebookImageQueryset)):
    pass


class UploadedProjectFileManager(UploadedFileManagerMixin, models.Manager.from_queryset(UploadedProjectFileQueryset)):
    pass

